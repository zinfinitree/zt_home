ZTIC 1    zinfinitree.com/doc1
ZTIC 2    zinfinitree.com/document
ZTIC 3    131131/21
ZTIC 4    zinfinitree.com/server_config
ZTIC 5    zinfinitree.com/spreadsheet
ZTIC 6    zinfinitree.com/multimedia_object
ZTIC 7    131131/22
ZTIC 8    zinfinitree.com/software
RZTI 1
MPPG 5179248000.000      abc123              123       99   user1     4    2    
EXTK 3    2    3    1    
MSET ObjectQset                              5179248000.000
ELEM 2    1    1    101  2    1                   Version 1.0 by Zinfinitem LLC
ELEM 2    1    1    101  2    3                   ZinfiniTree ZT Server--Base Specification
TYPE 2    1    1    101  2    1    2    1              
LINK 2    1    1    101  2    1    2    2    1    201                           5179248000.000           
LINK 2    1    1    101  2    1    2    2    1    202                           5179248000.000           
LINK 2    1    1    101  2    1    2    2    1    322                           5179248000.000           
LINK 2    1    1    101  2    1    2    2    1    323                           5179248000.000           
LINK 2    1    1    101  2    1    2    2    1    324                           5179248000.000           
LINK 2    1    1    101  2    1    2    2    1    325                           5179248000.000           
LINK 2    1    1    101  2    1    2    2    1    326                           5179248000.000           
ELEM 2    2    1    201  2    4                   Overview Heading
ELEM 2    2    1    201  2    5                   Overview
TYPE 2    2    1    201  2    2    2    1              
LINK 2    2    1    201  2    2    2    2    1    203                           5179248000.000      10000
LINK 2    2    1    201  2    2    2    2    1    206                      2    5179248000.000      9000 
LINK 2    2    1    201  2    2    2    2    1    218                           5179248000.000      8000 
LINK 2    2    1    201  2    2    2    2    1    219                           5179248000.000      7000 
LINK 2    2    1    201  2    2    2    2    1    222                           5179248000.000      6000 
LINK 2    2    1    201  2    2    2    2    1    225                           5179248000.000      5000 
LINK 2    2    1    201  2    2    2    2    1    565                           5179248000.000      9001 
ELEM 2    2    1    202  2    4                   Key Concepts Heading
ELEM 2    2    1    202  2    5                   Key Concepts
TYPE 2    2    1    202  2    2    2    1              
LINK 2    2    1    202  2    2    2    2    1    228                           5179248000.000      5000 
LINK 2    2    1    202  2    2    2    2    1    233                           5179248000.000      4500 
LINK 2    2    1    202  2    2    2    2    1    236                           5179248000.000      4000 
LINK 2    2    1    202  2    2    2    2    1    238                           5179248000.000      3000 
LINK 2    2    1    202  2    2    2    2    1    247                           5179248000.000      3500 
LINK 2    2    1    202  2    2    2    2    1    248                           5179248000.000      2500 
LINK 2    2    1    202  2    2    2    2    1    251                           5179248000.000      2400 
LINK 2    2    1    202  2    2    2    2    1    261                           5179248000.000      2300 
LINK 2    2    1    202  2    2    2    2    1    271                           5179248000.000      1800 
LINK 2    2    1    202  2    2    2    2    1    282                           5179248000.000      2000 
LINK 2    2    1    202  2    2    2    2    1    286                           5179248000.000      1900 
LINK 2    2    1    202  2    2    2    2    1    289                           5179248000.000      1700 
LINK 2    2    1    202  2    2    2    2    1    293                           5179248000.000      1600 
LINK 2    2    1    202  2    2    2    2    1    295                           5179248000.000      1500 
LINK 2    2    1    202  2    2    2    2    1    297                      2    5179248000.000           
LINK 2    2    1    202  2    2    2    2    1    299                      2    5179248000.000           
LINK 2    2    1    202  2    2    2    2    1    302                      2    5179248000.000           
LINK 2    2    1    202  2    2    2    2    1    314                      2    5179248000.000           
LINK 2    2    1    202  2    2    2    2    1    316                      2    5179248000.000           
ELEM 2    2    1    322  2    5                   Object Element Metadata
ELEM 2    2    1    322  2    4                   Object Element Metadata--Heading
TYPE 2    2    1    322  2    2    2    1              
LINK 2    2    1    322  2    2    2    2    1    327                           5179248000.000      10000
LINK 2    2    1    322  2    2    2    2    1    329                           5179248000.000      9000 
LINK 2    2    1    322  2    2    2    2    1    330                           5179248000.000      8000 
LINK 2    2    1    322  2    2    2    2    1    331                           5179248000.000      7000 
LINK 2    2    1    322  2    2    2    2    1    332                      2    5179248000.000           
LINK 2    2    1    322  2    2    2    2    1    333                           5179248000.000      6000 
LINK 2    2    1    322  2    2    2    2    1    334                           5179248000.000      5000 
LINK 2    2    1    322  2    2    2    2    1    335                           5179248000.000      4000 
LINK 2    2    1    322  2    2    2    2    1    336                           5179248000.000      3000 
ELEM 2    2    1    323  2    5                   Additional Features
ELEM 2    2    1    323  2    4                   Additional Features--Heading
TYPE 2    2    1    323  2    2    2    1              
LINK 2    2    1    323  2    2    2    2    1    350                           5179248000.000      8000 
LINK 2    2    1    323  2    2    2    2    1    369                      2    5179248000.000      4000 
LINK 2    2    1    323  2    2    2    2    1    361                           5179248000.000      6000 
LINK 2    2    1    323  2    2    2    2    1    314                           5179248000.000      7000 
LINK 2    2    1    323  2    2    2    2    1    447                           5179248000.000      5000 
LINK 2    2    1    323  2    2    2    2    1    297                      2    5179248000.000      9000 
LINK 2    2    1    323  2    2    2    2    1    316                           5179248000.000      10000
LINK 2    2    1    323  2    2    2    2    1    302                           5179248000.000      3000 
LINK 2    2    1    323  2    2    2    2    1    550                           5179248000.000      2500 
LINK 2    2    1    323  2    2    2    2    1    558                           5179248000.000      2400 
ELEM 2    2    1    324  2    5                   Message Processing
ELEM 2    2    1    324  2    4                   Message Processing--Heading
TYPE 2    2    1    324  2    2    2    1              
LINK 2    2    1    324  2    2    2    2    1    394                           5179248000.000           
LINK 2    2    1    324  2    3    5    1    1    1008                     2    5179248000.000           
LINK 2    2    1    324  2    2    2    2    1    396                           5179248000.000           
LINK 2    2    1    324  2    2    2    2    1    399                           5179248000.000           
LINK 2    2    1    324  2    2    2    2    1    400                           5179248000.000           
LINK 2    2    1    324  2    2    2    2    1    404                           5179248000.000           
ELEM 2    2    1    325  2    5                   ___________________________________________________________________
ELEM 2    2    1    325  2    4                   Core Applications--Heading - separator for appendix
TYPE 2    2    1    325  2    2    2    1              
ELEM 2    2    1    326  2    5                   Appendix
ELEM 2    2    1    326  2    4                   Appendix--Heading
TYPE 2    2    1    326  2    2    2    1              
LINK 2    2    1    326  2    2    2    2    1    380                           5179248000.000      10001
LINK 2    2    1    326  2    2    2    2    1    449                           5179248000.000      9500 
LINK 2    2    1    326  2    2    2    2    1    453                           5179248000.000      9800 
LINK 2    2    1    326  2    2    2    2    1    490                           5179248000.000      9200 
LINK 2    2    1    326  2    2    2    2    1    491                      1    5179248000.000      9100 
LINK 2    2    1    326  2    2    2    2    1    492                           5179248000.000      9000 
LINK 2    2    1    326  2    2    2    2    1    493                      1    5179248000.000      8900 
LINK 2    2    1    326  2    2    2    2    1    494                      1    5179248000.000      8800 
LINK 2    2    1    326  2    2    2    2    1    563                           5179248000.000      8700 
ELEM 2    2    1    203  2    4                   Overview Introduction Heading
ELEM 2    2    1    203  2    5                   Introduction
TYPE 2    2    1    203  2    2    2    1              
LINK 2    2    1    203  2    2    2    2    1    204                           5179248000.000           
LINK 2    2    1    203  2    2    2    2    1    381                           5179248000.000           
LINK 2    2    1    203  2    2    2    2    1    382                      2    5179248000.000           
LINK 2    2    1    203  2    2    2    2    1    383                           5179248000.000           
LINK 2    2    1    203  2    2    2    2    1    384                           5179248000.000           
LINK 2    2    1    203  2    2    2    2    1    385                           5179248000.000           
LINK 2    2    1    203  2    2    2    2    1    386                           5179248000.000           
ELEM 2    2    1    206  2    4                   Design Goals List Description
ELEM 2    2    1    206  2    5                   The specification for the ZT Server was developed with a set of Design Goals. An implementation of the specification for ZT Server along with certain core client applications (specified separately) should have the following capabilities:
TYPE 2    2    1    206  2    2    2    3              
LINK 2    2    1    206  2    2    2    2    1    207                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    208                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    209                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    213                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    214                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    215                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    216                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    217                      2    5179248000.000           
ELEM 2    2    1    218  2    4                   Overview Graphic Heading
ELEM 2    2    1    218  2    5                   ZT System--High Level Diagram
TYPE 2    2    1    218  2    2    2    1              
LINK 2    2    1    218  2    2    2    2    1    387                           5179248000.000           
ELEM 2    2    1    219  2    4                   Object Attributes Heading
ELEM 2    2    1    219  2    5                   Object Attributes
TYPE 2    2    1    219  2    2    2    1              
LINK 2    2    1    219  2    2    2    2    1    220                           5179248000.000           
LINK 2    2    1    219  2    2    2    2    1    221                      2    5179248000.000           
ELEM 2    2    1    222  2    4                   Specification Layers Heading
ELEM 2    2    1    222  2    5                   Specification Layers
TYPE 2    2    1    222  2    2    2    1              
LINK 2    2    1    222  2    2    2    2    1    223                           5179248000.000           
LINK 2    2    1    222  2    2    2    2    1    224                           5179248000.000           
ELEM 2    2    1    225  2    4                   Database Definition Heading
ELEM 2    2    1    225  2    5                   Database Definition
TYPE 2    2    1    225  2    2    2    1              
LINK 2    2    1    225  2    2    2    2    1    226                           5179248000.000           
LINK 2    2    1    225  2    2    2    2    1    227                           5179248000.000           
ELEM 2    2    1    565  2    4                   Design Goals List
ELEM 2    2    1    565  2    5                   Design Goals
TYPE 2    2    1    565  2    2    2    1              
LINK 2    2    1    565  2    2    2    2    1    566                      2    5179248000.000           
LINK 2    2    1    565  2    2    2    2    1    206                           5179248000.000      10000
LINK 2    2    1    565  2    2    2    2    1    567                           5179248000.000      9000 
ELEM 2    2    1    228  2    4                   Key Concepts Introduction--Heading
ELEM 2    2    1    228  2    5                   Introduction
TYPE 2    2    1    228  2    2    2    1              
LINK 2    2    1    228  2    2    2    2    1    229                           5179248000.000      9000 
LINK 2    2    1    228  2    2    2    2    1    230                           5179248000.000      10000
LINK 2    2    1    228  2    2    2    2    1    231                           5179248000.000      8000 
LINK 2    2    1    228  2    2    2    2    1    232                           5179248000.000      7000 
ELEM 2    2    1    233  2    4                   Object Kind Heading
ELEM 2    2    1    233  2    5                   Object Kinds
TYPE 2    2    1    233  2    2    2    1              
LINK 2    2    1    233  2    2    2    2    1    234                           5179248000.000           
LINK 2    2    1    233  2    2    2    2    1    235                           5179248000.000           
ELEM 2    2    1    236  2    4                   Codes--Heading
ELEM 2    2    1    236  2    5                   Codes
TYPE 2    2    1    236  2    2    2    1              
LINK 2    2    1    236  2    2    2    2    1    237                           5179248000.000           
ELEM 2    2    1    238  2    4                   Type Definitions--Heading
ELEM 2    2    1    238  2    5                   Type Definitions
TYPE 2    2    1    238  2    2    2    1              
LINK 2    2    1    238  2    2    2    2    1    240                           5179248000.000      9000 
LINK 2    2    1    238  2    2    2    2    1    485                      1    5179248000.000      2000 
LINK 2    2    1    238  2    2    2    2    1    239                           5179248000.000      10000
LINK 2    2    1    238  2    2    2    2    1    241                           5179248000.000      8000 
LINK 2    2    1    238  2    2    2    2    1    242                           5179248000.000      7000 
LINK 2    2    1    238  2    2    2    2    1    246                      2    5179248000.000      3000 
LINK 2    2    1    238  2    2    2    2    1    245                      2    5179248000.000      4000 
LINK 2    2    1    238  2    2    2    2    1    244                      2    5179248000.000      5000 
LINK 2    2    1    238  2    2    2    2    1    243                           5179248000.000      6000 
ELEM 2    2    1    247  2    4                   Object Element Heading
ELEM 2    2    1    247  2    5                   Object Elements
TYPE 2    2    1    247  2    2    2    1              
LINK 2    2    1    247  2    2    2    2    1    450                           5179248000.000           
ELEM 2    2    1    248  2    5                   Links
ELEM 2    2    1    248  2    4                   Link Heading
TYPE 2    2    1    248  2    2    2    1              
LINK 2    2    1    248  2    2    2    2    1    250                           5179248000.000      9000 
LINK 2    2    1    248  2    2    2    2    1    249                           5179248000.000      10000
ELEM 2    2    1    251  2    5                   Link Types
ELEM 2    2    1    251  2    4                   Link Type Heading
TYPE 2    2    1    251  2    2    2    1              
LINK 2    2    1    251  2    2    2    2    1    260                      2    5179248000.000           
LINK 2    2    1    251  2    2    2    2    1    259                      2    5179248000.000           
LINK 2    2    1    251  2    2    2    2    1    258                      2    5179248000.000           
LINK 2    2    1    251  2    2    2    2    1    257                      2    5179248000.000      5000 
LINK 2    2    1    251  2    2    2    2    1    256                      2    5179248000.000      6000 
LINK 2    2    1    251  2    2    2    2    1    255                           5179248000.000      7000 
LINK 2    2    1    251  2    2    2    2    1    254                           5179248000.000      8000 
LINK 2    2    1    251  2    2    2    2    1    253                           5179248000.000      9000 
LINK 2    2    1    251  2    2    2    2    1    252                           5179248000.000      10000
ELEM 2    2    1    261  2    5                   Link Target Types
ELEM 2    2    1    261  2    4                   Link Target Type--Heading
TYPE 2    2    1    261  2    2    2    1              
LINK 2    2    1    261  2    2    2    2    1    266                      2    5179248000.000      6000 
LINK 2    2    1    261  2    2    2    2    1    265                      2    5179248000.000      7000 
LINK 2    2    1    261  2    2    2    2    1    264                      2    5179248000.000      8000 
LINK 2    2    1    261  2    2    2    2    1    263                           5179248000.000      9000 
LINK 2    2    1    261  2    2    2    2    1    262                           5179248000.000      10000
LINK 2    2    1    261  2    2    2    2    1    267                      2    5179248000.000      5000 
LINK 2    2    1    261  2    2    2    2    1    268                      2    5179248000.000      4000 
LINK 2    2    1    261  2    2    2    2    1    269                      2    5179248000.000      3000 
LINK 2    2    1    261  2    2    2    2    1    270                      2    5179248000.000      2000 
ELEM 2    2    1    271  2    4                   Object Sets Heading
ELEM 2    2    1    271  2    5                   Object Sets
TYPE 2    2    1    271  2    2    2    1              
LINK 2    2    1    271  2    2    2    2    1    281                           5179248000.000      1000 
LINK 2    2    1    271  2    2    2    2    1    280                           5179248000.000      2000 
LINK 2    2    1    271  2    2    2    2    1    279                      2    5179248000.000      3000 
LINK 2    2    1    271  2    2    2    2    1    278                      2    5179248000.000      4000 
LINK 2    2    1    271  2    2    2    2    1    277                      2    5179248000.000      5000 
LINK 2    2    1    271  2    2    2    2    1    276                      2    5179248000.000      6000 
LINK 2    2    1    271  2    2    2    2    1    275                      2    5179248000.000      7000 
LINK 2    2    1    271  2    2    2    2    1    274                      2    5179248000.000      8000 
LINK 2    2    1    271  2    2    2    2    1    273                           5179248000.000      9000 
LINK 2    2    1    271  2    2    2    2    1    272                           5179248000.000      10000
ELEM 2    2    1    282  2    5                   Object Templates
ELEM 2    2    1    282  2    4                   Object Template Heading -- after links??
TYPE 2    2    1    282  2    2    2    1              
LINK 2    2    1    282  2    2    2    2    1    283                           5179248000.000      10000
LINK 2    2    1    282  2    2    2    2    1    284                           5179248000.000      9000 
LINK 2    2    1    282  2    2    2    2    1    285                           5179248000.000      8000 
ELEM 2    2    1    286  2    5                   Technical Profile
ELEM 2    2    1    286  2    4                   Technical Profile--Heading
TYPE 2    2    1    286  2    2    2    1              
LINK 2    2    1    286  2    2    2    2    1    288                           5179248000.000      9000 
LINK 2    2    1    286  2    2    2    2    1    287                           5179248000.000      10000
ELEM 2    2    1    289  2    4                   Type Based Template Rule--Heading
ELEM 2    2    1    289  2    5                   Type Value Based Template Rule
TYPE 2    2    1    289  2    2    2    1              
LINK 2    2    1    289  2    2    2    2    1    290                           5179248000.000      10000
LINK 2    2    1    289  2    2    2    2    1    291                           5179248000.000      9000 
LINK 2    2    1    289  2    2    2    2    1    292                           5179248000.000      8000 
ELEM 2    2    1    293  2    4                   Link Based Template Rule--Heading
ELEM 2    2    1    293  2    5                   Link Based Template Rule
TYPE 2    2    1    293  2    2    2    1              
LINK 2    2    1    293  2    2    2    2    1    294                           5179248000.000      10000
LINK 2    2    1    293  2    2    2    2    1    487                           5179248000.000      9000 
ELEM 2    2    1    295  2    5                   Object Element Value Based Template Rule
ELEM 2    2    1    295  2    4                   Object Element Value Based Template Rule--Heading
TYPE 2    2    1    295  2    2    2    1              
LINK 2    2    1    295  2    2    2    2    1    296                           5179248000.000           
ELEM 2    2    1    297  2    5                   Extended Key Definition
ELEM 2    2    1    297  2    4                   Extended Key Definition--Heading
TYPE 2    2    1    297  2    2    2    1              
LINK 2    2    1    297  2    2    2    2    1    298                           5179248000.000           
ELEM 2    2    1    299  2    4                   Roles Heading--MOVED to Additional Features
ELEM 2    2    1    299  2    5                   Roles--MOVED to Additional Features
TYPE 2    2    1    299  2    2    2    1              
LINK 2    2    1    299  2    2    2    2    1    300                           5179248000.000           
LINK 2    2    1    299  2    2    2    2    1    301                           5179248000.000           
ELEM 2    2    1    302  2    4                   Validation--Heading
ELEM 2    2    1    302  2    5                   Function Groups and Validation
TYPE 2    2    1    302  2    2    2    1              
LINK 2    2    1    302  2    2    2    2    1    311                      2    5179248000.000      2000 
LINK 2    2    1    302  2    2    2    2    1    303                           5179248000.000      10000
LINK 2    2    1    302  2    2    2    2    1    304                           5179248000.000      9000 
LINK 2    2    1    302  2    2    2    2    1    306                      2    5179248000.000      7000 
LINK 2    2    1    302  2    2    2    2    1    305                           5179248000.000      8000 
LINK 2    2    1    302  2    2    2    2    1    307                      2    5179248000.000      6000 
LINK 2    2    1    302  2    2    2    2    1    308                      2    5179248000.000      5000 
LINK 2    2    1    302  2    2    2    2    1    309                      2    5179248000.000      4000 
LINK 2    2    1    302  2    2    2    2    1    310                      2    5179248000.000      3000 
LINK 2    2    1    302  2    2    2    2    1    312                      2    5179248000.000      1000 
LINK 2    2    1    302  2    2    2    2    1    313                      2    5179248000.000      900  
ELEM 2    2    1    314  2    4                   Rationale and Approach to Versioning--Heading
ELEM 2    2    1    314  2    5                   Rationale and Approach to Versioning
TYPE 2    2    1    314  2    2    2    1              
LINK 2    2    1    314  2    2    2    2    1    315                           5179248000.000      10000
LINK 2    2    1    314  2    2    2    2    1    435                           5179248000.000      9000 
LINK 2    2    1    314  2    2    2    2    1    436                           5179248000.000      8000 
LINK 2    2    1    314  2    2    2    2    1    437                           5179248000.000      7000 
LINK 2    2    1    314  2    2    2    2    1    438                           5179248000.000      6000 
LINK 2    2    1    314  2    2    2    2    1    439                           5179248000.000      5000 
LINK 2    2    1    314  2    2    2    2    1    440                           5179248000.000      4000 
ELEM 2    2    1    316  2    4                   DS Instances
ELEM 2    2    1    316  2    5                   ZT Instances
TYPE 2    2    1    316  2    2    2    1              
LINK 2    2    1    316  2    2    2    2    1    445                           5179248000.000      1000 
LINK 2    2    1    316  2    2    2    2    1    317                           5179248000.000      10000
LINK 2    2    1    316  2    2    2    2    1    318                           5179248000.000      9000 
LINK 2    2    1    316  2    2    2    2    1    319                      2    5179248000.000      8000 
LINK 2    2    1    316  2    2    2    2    1    320                           5179248000.000      7000 
LINK 2    2    1    316  2    2    2    2    1    321                           5179248000.000      6000 
LINK 2    2    1    316  2    2    2    2    1    442                           5179248000.000      4000 
LINK 2    2    1    316  2    2    2    2    1    443                           5179248000.000      3000 
LINK 2    2    1    316  2    2    2    2    1    444                           5179248000.000      2000 
LINK 2    2    1    316  2    2    2    2    1    446                           5179248000.000      900  
LINK 2    2    1    316  2    2    2    2    1    454                           5179248000.000      950  
LINK 2    2    1    316  2    2    2    2    1    441                           5179248000.000      5000 
ELEM 2    2    1    327  2    5                   Introduction
ELEM 2    2    1    327  2    4                   Defining Meta-Data Introduction--Heading
TYPE 2    2    1    327  2    2    2    1              
LINK 2    2    1    327  2    2    2    2    1    328                           5179248000.000           
ELEM 2    2    1    329  2    5                   Object Element
ELEM 2    2    1    329  2    4                   Object Element--Heading
TYPE 2    2    1    329  2    2    2    1              
LINK 2    2    1    329  2    2    2    2    1    337                           5179248000.000           
ELEM 2    2    1    330  2    4                   Object Element Usage Type--Heading
ELEM 2    2    1    330  2    5                   Object Element Usage Type
TYPE 2    2    1    330  2    2    2    1              
LINK 2    2    1    330  2    2    2    2    1    338                           5179248000.000      10000
LINK 2    2    1    330  2    2    2    2    1    339                      2    5179248000.000      9000 
LINK 2    2    1    330  2    2    2    2    1    340                      2    5179248000.000      8000 
LINK 2    2    1    330  2    2    2    2    1    341                           5179248000.000      7000 
LINK 2    2    1    330  2    2    2    2    1    343                           5179248000.000      5000 
LINK 2    2    1    330  2    2    2    2    1    342                           5179248000.000      6000 
ELEM 2    2    1    331  2    5                   Data Element
ELEM 2    2    1    331  2    4                   Data Element--Heading
TYPE 2    2    1    331  2    2    2    1              
LINK 2    2    1    331  2    2    2    2    1    344                           5179248000.000      10000
LINK 2    2    1    331  2    2    2    2    1    467                           5179248000.000      9000 
ELEM 2    2    1    332  2    4                   Table Element--Heading
ELEM 2    2    1    332  2    5                   Table Element
TYPE 2    2    1    332  2    2    2    1              
ELEM 2    2    1    333  2    4                   Data Type--Heading
ELEM 2    2    1    333  2    5                   Data Type
TYPE 2    2    1    333  2    2    2    1              
LINK 2    2    1    333  2    2    2    2    1    345                           5179248000.000           
ELEM 2    2    1    334  2    5                   Validation of Character Values
ELEM 2    2    1    334  2    4                   Validation Character Values--Heading
TYPE 2    2    1    334  2    2    2    1              
LINK 2    2    1    334  2    2    2    2    1    346                           5179248000.000           
ELEM 2    2    1    335  2    5                   Numeric Data Type Details
ELEM 2    2    1    335  2    4                   Numeric Data Type Details--Heading
TYPE 2    2    1    335  2    2    2    1              
LINK 2    2    1    335  2    2    2    2    1    347                           5179248000.000      10000
LINK 2    2    1    335  2    2    2    2    1    348                      2    5179248000.000      9000 
ELEM 2    2    1    336  2    5                   Extended Key Definition
ELEM 2    2    1    336  2    4                   Extended Key Definition--Heading
TYPE 2    2    1    336  2    2    2    1              
LINK 2    2    1    336  2    2    2    2    1    349                           5179248000.000      9000 
LINK 2    2    1    336  2    2    2    2    1    468                           5179248000.000      10000
LINK 2    2    1    336  2    2    2    2    1    469                           5179248000.000      8000 
LINK 2    2    1    336  2    2    2    2    1    470                           5179248000.000      7000 
LINK 2    2    1    336  2    2    2    2    1    471                           5179248000.000      6000 
ELEM 2    2    1    350  2    4                   Timestamp Implementation--Heading
ELEM 2    2    1    350  2    5                   Timestamp Implementation
TYPE 2    2    1    350  2    2    2    1              
LINK 2    2    1    350  2    2    2    2    1    357                           5179248000.000      4000 
LINK 2    2    1    350  2    2    2    2    1    352                      2    5179248000.000      9000 
LINK 2    2    1    350  2    2    2    2    1    353                           5179248000.000      8000 
LINK 2    2    1    350  2    2    2    2    1    354                           5179248000.000      7000 
LINK 2    2    1    350  2    2    2    2    1    355                      2    5179248000.000      6000 
LINK 2    2    1    350  2    2    2    2    1    356                           5179248000.000      5000 
LINK 2    2    1    350  2    2    2    2    1    358                           5179248000.000      3000 
LINK 2    2    1    350  2    2    2    2    1    359                      2    5179248000.000      2000 
LINK 2    2    1    350  2    2    2    2    1    360                      2    5179248000.000      1500 
LINK 2    2    1    350  2    2    2    2    1    351                           5179248000.000      10000
ELEM 2    2    1    369  2    4                   Data Protection--Heading
ELEM 2    2    1    369  2    5                   Data Protection
TYPE 2    2    1    369  2    2    2    1              
LINK 2    2    1    369  2    2    2    2    1    377                           5179248000.000           
LINK 2    2    1    369  2    2    2    2    1    376                           5179248000.000           
LINK 2    2    1    369  2    2    2    2    1    374                           5179248000.000           
LINK 2    2    1    369  2    2    2    2    1    372                           5179248000.000           
LINK 2    2    1    369  2    2    2    2    1    370                           5179248000.000           
ELEM 2    2    1    361  2    5                   Code Assignment
ELEM 2    2    1    361  2    4                   Code Assignment--Heading
TYPE 2    2    1    361  2    2    2    1              
LINK 2    2    1    361  2    2    2    2    1    368                           5179248000.000      4000 
LINK 2    2    1    361  2    2    2    2    1    367                           5179248000.000      5000 
LINK 2    2    1    361  2    2    2    2    1    366                           5179248000.000      6000 
LINK 2    2    1    361  2    2    2    2    1    365                           5179248000.000      7000 
LINK 2    2    1    361  2    2    2    2    1    362                           5179248000.000      10000
LINK 2    2    1    361  2    2    2    2    1    363                           5179248000.000      9000 
LINK 2    2    1    361  2    2    2    2    1    364                           5179248000.000      8000 
ELEM 2    2    1    314  2    4                   Rationale and Approach to Versioning--Heading
ELEM 2    2    1    314  2    5                   Rationale and Approach to Versioning
TYPE 2    2    1    314  2    2    2    1              
LINK 2    2    1    314  2    2    2    2    1    315                           5179248000.000      10000
LINK 2    2    1    314  2    2    2    2    1    435                           5179248000.000      9000 
LINK 2    2    1    314  2    2    2    2    1    436                           5179248000.000      8000 
LINK 2    2    1    314  2    2    2    2    1    437                           5179248000.000      7000 
LINK 2    2    1    314  2    2    2    2    1    438                           5179248000.000      6000 
LINK 2    2    1    314  2    2    2    2    1    439                           5179248000.000      5000 
LINK 2    2    1    314  2    2    2    2    1    440                           5179248000.000      4000 
ELEM 2    2    1    447  2    4                   Server Definition--Heading
ELEM 2    2    1    447  2    5                   Server Definition
TYPE 2    2    1    447  2    2    2    1              
LINK 2    2    1    447  2    2    2    2    1    448                           5179248000.000           
ELEM 2    2    1    297  2    5                   Extended Key Definition
ELEM 2    2    1    297  2    4                   Extended Key Definition--Heading
TYPE 2    2    1    297  2    2    2    1              
LINK 2    2    1    297  2    2    2    2    1    298                           5179248000.000           
ELEM 2    2    1    316  2    4                   DS Instances
ELEM 2    2    1    316  2    5                   ZT Instances
TYPE 2    2    1    316  2    2    2    1              
LINK 2    2    1    316  2    2    2    2    1    445                           5179248000.000      1000 
LINK 2    2    1    316  2    2    2    2    1    317                           5179248000.000      10000
LINK 2    2    1    316  2    2    2    2    1    318                           5179248000.000      9000 
LINK 2    2    1    316  2    2    2    2    1    319                      2    5179248000.000      8000 
LINK 2    2    1    316  2    2    2    2    1    320                           5179248000.000      7000 
LINK 2    2    1    316  2    2    2    2    1    321                           5179248000.000      6000 
LINK 2    2    1    316  2    2    2    2    1    442                           5179248000.000      4000 
LINK 2    2    1    316  2    2    2    2    1    443                           5179248000.000      3000 
LINK 2    2    1    316  2    2    2    2    1    444                           5179248000.000      2000 
LINK 2    2    1    316  2    2    2    2    1    446                           5179248000.000      900  
LINK 2    2    1    316  2    2    2    2    1    454                           5179248000.000      950  
LINK 2    2    1    316  2    2    2    2    1    441                           5179248000.000      5000 
ELEM 2    2    1    302  2    4                   Validation--Heading
ELEM 2    2    1    302  2    5                   Function Groups and Validation
TYPE 2    2    1    302  2    2    2    1              
LINK 2    2    1    302  2    2    2    2    1    311                      2    5179248000.000      2000 
LINK 2    2    1    302  2    2    2    2    1    303                           5179248000.000      10000
LINK 2    2    1    302  2    2    2    2    1    304                           5179248000.000      9000 
LINK 2    2    1    302  2    2    2    2    1    306                      2    5179248000.000      7000 
LINK 2    2    1    302  2    2    2    2    1    305                           5179248000.000      8000 
LINK 2    2    1    302  2    2    2    2    1    307                      2    5179248000.000      6000 
LINK 2    2    1    302  2    2    2    2    1    308                      2    5179248000.000      5000 
LINK 2    2    1    302  2    2    2    2    1    309                      2    5179248000.000      4000 
LINK 2    2    1    302  2    2    2    2    1    310                      2    5179248000.000      3000 
LINK 2    2    1    302  2    2    2    2    1    312                      2    5179248000.000      1000 
LINK 2    2    1    302  2    2    2    2    1    313                      2    5179248000.000      900  
ELEM 2    2    1    550  2    4                   Statistical Values--Heading
ELEM 2    2    1    550  2    5                   Statistical Values
TYPE 2    2    1    550  2    2    2    1              
LINK 2    2    1    550  2    2    2    2    1    551                           5179248000.000      9000 
LINK 2    2    1    550  2    2    2    2    1    552                           5179248000.000      8000 
LINK 2    2    1    550  2    2    2    2    1    553                           5179248000.000      7000 
LINK 2    2    1    550  2    2    2    2    1    554                           5179248000.000      6000 
LINK 2    2    1    550  2    2    2    2    1    555                           5179248000.000      5000 
LINK 2    2    1    550  2    2    2    2    1    556                           5179248000.000      4000 
LINK 2    2    1    550  2    2    2    2    1    557                           5179248000.000      3000 
ELEM 2    2    1    558  2    4                   Response Type--Heading
ELEM 2    2    1    558  2    5                   Response Types
TYPE 2    2    1    558  2    2    2    1              
LINK 2    2    1    558  2    2    2    2    1    559                           5179248000.000      9000 
LINK 2    2    1    558  2    2    2    2    1    570                           5179248000.000      10000
LINK 2    2    1    558  2    2    2    2    1    571                           5179248000.000      9500 
LINK 2    2    1    558  2    2    2    2    1    572                           5179248000.000      8000 
LINK 2    2    1    558  2    2    2    2    1    573                           5179248000.000      7000 
ELEM 2    2    1    394  2    5                   Introduction
ELEM 2    2    1    394  2    4                   Message Processing Introduction--Heading
TYPE 2    2    1    394  2    2    2    1              
LINK 2    2    1    394  2    2    2    2    1    395                           5179248000.000           
ELEM 5    1    1    1008 5    1                   Message Structure
ELEM 5    1    1    1008 5    2                   Message Structure
ELEM 5    1    1    1008 5    3                   
LINK 5    1    1    1008 5    1    5    2    1    2009                          5179248000.000           
ELEM 2    2    1    396  2    5                   Message Definition
ELEM 2    2    1    396  2    4                   Message Definition-Heading
TYPE 2    2    1    396  2    2    2    1              
LINK 2    2    1    396  2    2    2    2    1    425                           5179248000.000      5000 
LINK 2    2    1    396  2    2    2    2    1    424                           5179248000.000      6000 
LINK 2    2    1    396  2    2    2    2    1    423                           5179248000.000      7000 
LINK 2    2    1    396  2    2    2    2    1    422                           5179248000.000      8000 
LINK 2    2    1    396  2    2    2    2    1    421                           5179248000.000      9000 
LINK 2    2    1    396  2    2    2    2    1    397                           5179248000.000      10000
ELEM 2    2    1    399  2    5                   Message Syntax
ELEM 2    2    1    399  2    4                   Message Syntax--Heading
TYPE 2    2    1    399  2    2    2    1              
LINK 2    2    1    399  2    2    2    2    1    403                           5179248000.000      8000 
LINK 2    2    1    399  2    2    2    2    1    402                           5179248000.000      9000 
LINK 2    2    1    399  2    2    2    2    1    401                           5179248000.000      10000
LINK 2    2    1    399  2    2    2    2    1    488                           5179248000.000      7000 
ELEM 2    2    1    400  2    5                   Message Processing Steps
ELEM 2    2    1    400  2    4                   Message Processing Steps--Heading
TYPE 2    2    1    400  2    2    2    1              
LINK 2    2    1    400  2    2    2    2    1    405                           5179248000.000           
ELEM 2    2    1    404  2    5                   Message Processing Example
ELEM 2    2    1    404  2    4                   Message Processing Example--Heading
TYPE 2    2    1    404  2    2    2    1              
LINK 2    2    1    404  2    2    2    2    1    416                           5179248000.000      10000
LINK 2    2    1    404  2    2    2    2    1    417                           5179248000.000      9000 
LINK 2    2    1    404  2    2    2    2    1    418                           5179248000.000      8000 
LINK 2    2    1    404  2    2    2    2    1    419                           5179248000.000      7000 
LINK 2    2    1    404  2    2    2    2    1    420                           5179248000.000      6000 
ELEM 2    2    1    380  2    5                   Appendix 1--Object Kinds
ELEM 2    2    1    380  2    4                   Appendix 1--Heading--Object Kinds
TYPE 2    2    1    380  2    2    2    1              
LINK 2    2    1    380  2    3    5    1    1    1001                     2    5179248000.000           
LINK 2    2    1    380  2    2    2    2    1    480                           5179248000.000      10000
ELEM 2    2    1    449  2    4                   Appendix 3--Heading--Type Definitions
ELEM 2    2    1    449  2    5                   Appendix 3--Type Definitions
TYPE 2    2    1    449  2    2    2    1              
LINK 2    2    1    449  2    3    5    1    1    1020                     2    5179248000.000           
LINK 2    2    1    449  2    2    2    2    1    541                           5179248000.000           
ELEM 2    2    1    453  2    4                   Appendix 2--Heading--Object Elements
ELEM 2    2    1    453  2    5                   Appendix 2--Object Elements
TYPE 2    2    1    453  2    2    2    1              
LINK 2    2    1    453  2    3    5    1    1    1021                     2    5179248000.000           
LINK 2    2    1    453  2    2    2    2    1    540                           5179248000.000           
ELEM 2    2    1    490  2    4                   Appendix 4--Heading--Link Types
ELEM 2    2    1    490  2    5                   Appendix 4--Link Types
TYPE 2    2    1    490  2    2    2    1              
LINK 2    2    1    490  2    3    5    1    1    1023                     2    5179248000.000           
LINK 2    2    1    490  2    2    2    2    1    542                           5179248000.000           
ELEM 2    2    1    491  2    4                   Appendix 5--Heading--Table Elements
ELEM 2    2    1    491  2    5                   Appendix 5--Table Elements
TYPE 2    2    1    491  2    2    2    1              
LINK 2    2    1    491  2    2    2    2    1    543                           5179248000.000           
ELEM 2    2    1    492  2    4                   Appendix 6--Heading--Object Template
ELEM 2    2    1    492  2    5                   Appendix 6--Standard Message Definition
TYPE 2    2    1    492  2    2    2    1              
LINK 2    2    1    492  2    2    2    2    1    546                           5179248000.000           
ELEM 2    2    1    493  2    4                   Appendix 7--Heading--Base Object Element Values
ELEM 2    2    1    493  2    5                   Appendix 7--Base Object Element Values
TYPE 2    2    1    493  2    2    2    1              
LINK 2    2    1    493  2    2    2    2    1    561                           5179248000.000           
ELEM 2    2    1    494  2    4                   Appendix 8--Heading--Base Type Values
ELEM 2    2    1    494  2    5                   Apprendix 8--Base Type Values
TYPE 2    2    1    494  2    2    2    1              
LINK 2    2    1    494  2    2    2    2    1    562                           5179248000.000           
ELEM 2    2    1    563  2    4                   Appendix 9--Heading--Base Links
ELEM 2    2    1    563  2    5                   Appendix 9--Base Links
TYPE 2    2    1    563  2    2    2    1              
LINK 2    2    1    563  2    2    2    2    1    564                           5179248000.000           
ELEM 2    2    1    204  2    5                   The purpose of this document is to provide a Base Specification for the ZinfiniTree ZT Server by Zinfinitem LLC.  The ZT Server is designed as an extensible platform for building, deploying, running and sharing applications.
ELEM 2    2    1    204  2    4                   Overview Introduction--Paragraph 1
ELEM 2    2    1    381  2    5                   The specification describes a system especially suited for storing data related to objects where the rules for storing the data are very exact but where those rules are expected to change significantly during the lifetime of the object.  While the rules change over time, there is still need to retain continuity of identification.  As an example, a person is often thought of as a single continuous entity that retains an existence from birth until death.     A person goes through dramatic changes in size, appearance, abilities, needs, wants, legal status and relationships throughout his/her life.  Some people experience a change in their name at various points but are still thought of as the same person.  As another example, a company over time can change its customers, employees, suppliers, products or ownership.  It can acquire other companies and even change its name but in the minds of most people, it retains a continuous chain of existence.
ELEM 2    2    1    381  2    4                   Overview Introduction--Paragraph 2
ELEM 2    2    1    382  2    4                   Overview Introduction--Paragraph 3
ELEM 2    2    1    382  2    5                   x
ELEM 2    2    1    383  2    4                   Overview Introduction--Paragraph 4
ELEM 2    2    1    383  2    5                   The specification is also oriented towards handing data that needs to be viewed from multiple perspectives.  This includes, for example, maintaining the object in multiple human languages and for multiple roles.  Roles in the context of a company could include, for example, customer or vendor.
ELEM 2    2    1    384  2    4                   Overview Introduction--Paragraph 5
ELEM 2    2    1    384  2    5                   As the name ZT Server implies, an implementation of a ZT Server would fill the role of a server in a client server relationship.   As with a typical client server relationship, the client sends requests to the server.  The ZT Server receives the request, processes it and returns a response.  Persisted data can be stored by the server in a conventional database.  The document describes the requirements of the ZT server and includes a definition of messages that could flow between a client and the server.
ELEM 2    2    1    385  2    4                   Overview Introduction--Paragraph 6
ELEM 2    2    1    385  2    5                   Although the server contains features that are intended to be useful to the client, there is no specification for the client in the base specification except that it must be able to pass messages to the server using a protocol that the server supports.  The client must be able to receive the response from the server and presumably be able to perform something useful with it.  The client would typically handle the interaction with human users (if they exist).
ELEM 2    2    1    386  2    4                   Overview Introduction--Paragraph 7
ELEM 2    2    1    386  2    5                   The request to the server will usually be to maintain (create or change) data used to represent objects on the server or to retrieve data that was previously stored.  In this sense a ZT Server is conceptually similar to a conventional database server.
ELEM 2    2    1    207  2    4                   Design Goal #1
ELEM 2    2    1    207  2    5                   It should be possible to build applications with minimal programming using generically defined objects.
ELEM 2    2    1    208  2    5                   Applications should be multi-language (human) without having to do any special coding.
ELEM 2    2    1    208  2    4                   Design Goal #2
ELEM 2    2    1    209  2    5                   It should be possible to extend ZT Server applications and combine them with other ZT Server applications with minimal or no coding.
ELEM 2    2    1    209  2    4                   Design Goal #3
ELEM 2    2    1    213  2    4                   Design Goal #4
ELEM 2    2    1    213  2    5                   Applications should have access to a complete change history without coding.  Objects that are linked to older versions of other objects should have access to the older values even if a new version of the object being linked to has changed.
ELEM 2    2    1    214  2    5                   It should be easy for users to share data and applications with each other.
ELEM 2    2    1    214  2    4                   Design Goal #5
ELEM 2    2    1    215  2    5                   It should be easy to identify the source of any objects in the system.  It should also be easy to remove unwanted objects that were previously imported or created based on source or other criteria.
ELEM 2    2    1    215  2    4                   Design Goal #6
ELEM 2    2    1    216  2    4                   Design Goal #7
ELEM 2    2    1    216  2    5                   The design should be understandable and accessible.  A person should be able to move from being an application user to application configurator to application developer to client or server developer in a natural progression.
ELEM 2    2    1    217  2    5                   It should be possible to implement the design with a reasonable amount of effort using industry standard protocols and products that are available in open source implementations.
ELEM 2    2    1    217  2    4                   Design Goal #8
ELEM 2    2    1    387  2    5                   The graphic below depicts the relationship between the ZT Server and a client.  The client initiates the relationship by sending a message to the server to maintain data on the server or to query data previously stored on the server.  The server parses the message and interacts with data in a conventional database to process the message.  The server then prepares a response message to indicate which data was maintained, return the data queried or return an appropriate error message.
ELEM 2    2    1    387  2    4                   High Level Diagram--Paragraph #1
LINK 2    2    1    387  2    4    6    1    1    1001                          5179248000.000           
ELEM 2    2    1    220  2    5                   ZT Applications are maintained on a server by defining objects.  The attributes of an object fall into four categories, Object Element values, Type values, Links and Maintained Templates.  These are described in more detail in the Key Concepts section of this document.
ELEM 2    2    1    220  2    4                   Object Attributes Paragraph #1
ELEM 2    2    1    221  2    5                   x
ELEM 2    2    1    221  2    4                   Object Attributes Paragraph #2
ELEM 2    2    1    223  2    5                   This Base Specification is described in abstract terms, independent of the details of implementation.  Other specifications can be added that reference specific industry standards and protocols or add details not addressed by the base specification.  The intention is that the Base Specification will eventually become stable.  Other specifications are added to aid implementation and will adapt as surrounding technologies change.
ELEM 2    2    1    223  2    4                   Specification Layers--Paragraph #1
ELEM 2    2    1    224  2    5                   The functionality of a ZT Server is built using multiple layers.  Application developers can add functionality to an existing system.  One developer can enrich the work of another.  The Base Specification can be viewed as the trunk of a tree.  Each specification that builds on the Base Specification elongates the trunk of the tree.  There may be cases where two developers have competing work.  This is like growing branches of the tree.  There may be situations where two branches each contain valuable content.  An integrator can take elements from each branch to build a third branch, modify it if necessary, test it and then distribute it to other users.  Developers are free to add to standard specifications or branch (fork) them to meet their needs.
ELEM 2    2    1    224  2    4                   Specification Layers--Paragraph #2
ELEM 2    2    1    226  2    4                   Database Definition Paragraph #1
ELEM 2    2    1    226  2    5                   Any ZT Server implementation that can handle a request message that conforms to the standards and returns an appropriate response would be in compliance with the specification.  However, it may be easier to understand the thinking behind the design of the messages if we also look at how data could be maintained on the server to achieve the design goals.
ELEM 2    2    1    227  2    4                   Database Definition Paragraph #2
ELEM 2    2    1    227  2    5                   It was mentioned that the ZT Server can be connected to a conventional database.  The database in the base specification is also an abstraction.  It is considered to be a system that can store and retrieve data in/from tables.  A table consists of rows and columns.  The database must be able to retrieve data based on values being selected using a particular syntax.  Typically databases support a variety of data types.  The standard elements, those included in this specification, can be accommodated using only character data and correspond to a database field or column.  Objects such as graphics, audio/video clips and web resources etc are supported by referring to locations that are possibly outside of the conventional database.
ELEM 2    2    1    566  2    4                   Design Goals list intro
ELEM 2    2    1    566  2    5                   
LINK 2    2    1    566  2    2    2    2    1    206                           5179248000.000           
LINK 2    2    1    566  2    3    5    1    1    1050                     2    5179248000.000           
LINK 2    2    1    566  2    2    2    2    1    567                           5179248000.000           
ELEM 2    2    1    206  2    4                   Design Goals List Description
ELEM 2    2    1    206  2    5                   The specification for the ZT Server was developed with a set of Design Goals. An implementation of the specification for ZT Server along with certain core client applications (specified separately) should have the following capabilities:
TYPE 2    2    1    206  2    2    2    3              
LINK 2    2    1    206  2    2    2    2    1    207                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    208                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    209                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    213                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    214                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    215                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    216                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    217                      2    5179248000.000           
ELEM 2    2    1    567  2    4                   Goals for document itself
ELEM 2    2    1    567  2    5                   In addition, listed below are goals for the specification document itself:
TYPE 2    2    1    567  2    2    2    3              
LINK 2    2    1    567  2    2    2    2    1    568                           5179248000.000      10000
LINK 2    2    1    567  2    2    2    2    1    569                           5179248000.000      9000 
ELEM 2    2    1    229  2    4                   Key Concepts Introduction--Paragraph #2
ELEM 2    2    1    229  2    5                   There are several aspects of the data organization that are used to achieve the design goals:
TYPE 2    2    1    229  2    2    2    3              
LINK 2    2    1    229  2    2    2    2    1    393                           5179248000.000      2500 
LINK 2    2    1    229  2    2    2    2    1    392                           5179248000.000      3000 
LINK 2    2    1    229  2    2    2    2    1    391                           5179248000.000      2000 
LINK 2    2    1    229  2    2    2    2    1    390                           5179248000.000      3500 
LINK 2    2    1    229  2    2    2    2    1    389                           5179248000.000      4000 
LINK 2    2    1    229  2    2    2    2    1    451                           5179248000.000      1500 
LINK 2    2    1    229  2    2    2    2    1    452                           5179248000.000      1000 
LINK 2    2    1    229  2    2    2    2    1    486                           5179248000.000      500  
LINK 2    2    1    229  2    2    2    2    1    388                           5179248000.000      5000 
ELEM 2    2    1    230  2    5                   This section addresses some of the key concepts related to data organization
ELEM 2    2    1    230  2    4                   Key Concepts Introduction--Paragraph #1
ELEM 2    2    1    231  2    5                   The Table Elements in the Base Specification are listed in Appendix 5.  The purpose of these are explained in later sections of this document.  Each Table Element has been assigned a numeric code to identify it.
ELEM 2    2    1    231  2    4                   Key Concepts Introduction--Paragraph #2
LINK 2    2    1    231  2    3    5    1    1    1005                     2    5179248000.000           
ELEM 2    2    1    232  2    5                   The use of these Table Elements could vary by implementation.  One approach would be to include all of the Table Elements in a single physical database table.  In this case table elements not used for a particular row could be left blank.  Alternatively, as an example, the values for Server DB--ZT Instance ID or Record Type ZT Instance Code and Record Type Code could be embedded in the table name and thereby spreading the contents into multiple physical database tables and minimizing the number blank elements required.  The implementer could also choose other table schemas to i.e. increase efficiency of data access.
ELEM 2    2    1    232  2    4                   Key Concepts Introduction--Paragraph #3
ELEM 2    2    1    234  2    4                   Object Kind--Paragraph #1
ELEM 2    2    1    234  2    5                   Every object stored on the ZT server is assigned to an Object Kind.  Some Object Kinds are part of the Base Specification and are used implement the ZT server.  Other Object Kinds can be created by application developers.  The Object Kinds defined would depend on the problem domain.  For example, a individual may want to use Object Kinds to represent things such as persons, addresses, appointments.  A business person may also be interested in Object Kinds that represent customers, sales orders and accounts.  A chemist may be interested in an Object Kind that represents elements from the periodic table or an Object Kind to represent units of measure.  Object Kinds use Object Kind Code 1.  A list of the Object Kinds from the Base Specification can be found in Appendix 1.  For objects created using Object Kinds from the  Base Specification, the Object Codes shown in Appendix 1 are used in Table Element 2 to indicate the Kind of data being represented in that table row.  Other Object Kinds will have their Codes assigned in the source ZT Instance.  Table Element 1, which contains the Object Kind ZT Instance Code is used to differentiate the Object Kinds from different sources even though they may share the same Code.
ELEM 2    2    1    235  2    4                   Object Kind--Paragraph #2
ELEM 2    2    1    235  2    5                   Frequently the terms object kind and table will be used interchangeably.  For example it could be said that this group of objects will be stored in the Person table meaning they are all of Object Kind Person.  This translates roughly to the use of the term table in a relational database.  It is not to imply that all of the objects will be stored in one physical database table.  The implementer of the specification can decide how data will be apportioned to database tables.
ELEM 2    2    1    237  2    4                   Codes--Paragraph #1
ELEM 2    2    1    237  2    5                   The Code is used to identify individual instances of an object within the tables for an object kind.  It could take the form of a sequentially assigned series of numbers and/or letters or Codes could be assigned by the client (user).  A Code along with the Code ZT Instance Code  uniquely identify an Object of a specific Kind.  The ZT Instance code identifies the source of an object, meaning the ZT Instance that the object originated from.  No maximum code length is specified in the Base Specification, but it will be included in other specifications that are layered on top of Base Specification. Codes used to identify objects referred to in the Base Specification itself will be pure numeric values to make them more easily usable in multiple human languages.  Codes assigned by users will not have this limitation although they may choose to follow this convention if they wish to distribute their objects in multiple languages.
ELEM 2    2    1    240  2    5                   Object Type relationships are configured using Type Definitions.  Type Definition is an Object Kind that also uses two separate Type Definitions in its own definition.  The first Type Definition is used to indicate the Object Kind of the type values.  The second Type Definition is used to indicate the Object Set to determine valid Type Values.  For example a Type Definition could be set up so that Object Kind, Size will act as a Type Table for Object Kind, Shirt.  The Type Definition for Shirt Size for a Shirt would need to specify Object Kind, Shirt Size as a Type Value to indicate that Shirt Size will contain the type values.  The Type Definition would also specify an Object Set of Shirt Sizes as the Set of possible type values, small, medium, large, extra-large etc.
ELEM 2    2    1    240  2    4                   Type Definitions--Paragraph #2
ELEM 2    2    1    485  2    4                   Type Definitions--Paragraph #9
ELEM 2    2    1    485  2    5                   There is a specialized case that allows the automatic creation of links based on a type relationship.  To do this a Type Definition can also use Link Type as a Type Table (Type Definition Code 24).  The Type Value for this Type Definition indicates that it is a Link Type that will be used to create server generated links from the object being used as a type value to the object being typed.  This creates essentially a bi-directional link between an object and the object being used as a type value.  As an example, suppose that an application contains financial posting line items and accounting document as Object Kinds.  The line items uses document as Type Value to indicate the document that the line item relates to.  Suppose there is a desire to see all the line items for a particular document.  In this case it is useful to have a link from the document (the Type Value) to the line item.  The server is required to automatically create the link if the Type Definition is properly configured, specifying the Link Type as a Type Value.
ELEM 2    2    1    239  2    5                   Object Types are used to categorize instances of an Object Kind.  The Type of an object is also used to identify objects that should share a certain behavior, i.e. data content, display characteristics and permitted/required linkages to other objects.  The possible types for an Object Kind are always validated against the objects of another Object Kind.  The Object Kind used for this validation is referred to as the Type Table.  The specific instance of an the object in the Type Table is referred to as the Type Value.  For example if Object Kind Country serves as the Type Table for Object Kind Address then Mexico could be the Type Value for a specific Address.  More specifically the ZT Instance Code and Code for Mexico would make up the Type Value for the address.  When a Type Values are maintained for a specific instance of an Object Kind, the server checks that the Type(s) specified exists in the ZT Instance Code and Code elements of the related Type Table(s).
ELEM 2    2    1    239  2    4                   Type Definitions--Paragraph #1
ELEM 2    2    1    241  2    5                   Type Definitions are use Object Kind Code 9.  A list of the Type Definitions can be found in Appendix 3.  Type Definitions become active by creating a link from a Technical Profile to the Type Definition.  The link makes type relationships possible/required when an object is maintained using an Object Template that utilizes the Technical Profile.  Object Templates and Technical Profiles are explained later in this section of the document.
ELEM 2    2    1    241  2    4                   Type Definitions--Paragraph #3
ELEM 2    2    1    242  2    4                   Type Definitions--Paragraph #4
ELEM 2    2    1    242  2    5                   A given Object Kind, for example Country, can serve  as the Type Table for multiple Object Kinds.  For example, Object Kind address could use country as a type table and also state/province could use country as a type table.  Also an object kind can have multiple type tables.  For example an Object Kind for cat could have a type table for sex and another Type Table for breed (Persian, Bengal, Siamese etc).  To remove ambiguity when referring to an object type the convention of stating the name of the Type Definition followed by the type value separated by a colon is used.  For example, one can refer to a cat of type Cat sex:male, a cat of type Cat breed:Persian or a address of type Country:Mexico.
ELEM 2    2    1    246  2    5                   -
ELEM 2    2    1    246  2    4                   Type Definitions--Paragraph #8
ELEM 2    2    1    245  2    5                   While changing a type value for an object is technically possible, changing of the type table relationship can have a profound effect  if objects were already created assuming the initial Type Table relationship.  If this occurs, all of the linkages that are required by the new Type must be added in the same logical unit of work, via the same request message.  Linkages that are now prohibited must be deactivated in that same logical unit of work.  If the Type Table linked to is changed, the server needs to check if all objects have a valid Type before allowing the change to be saved.
ELEM 2    2    1    245  2    4                   Type Definitions--Paragraph #7
ELEM 2    2    1    244  2    4                   Type Definitions--Paragraph #6
ELEM 2    2    1    244  2    5                   Assigning a Type Table relationship is most useful when the object will have a fixed or stable relationship to the Type Table and Type Value, in many cases for the life of an object.  While changing a Type Value for an object is technically possible, changing of the Type Table relationship can have a profound effect if objects were already created assuming the initial Type Table relationship. If this occurs, all of the linkages that are required by the new Type must be added in the same logical unit of work, via the same request message. Linkages that are now prohibited must be deactivated in that same logical unit of work. If the Type Table linked to is changed, the server needs to check if all objects have a valid Type before allowing the change to be saved...
ELEM 2    2    1    243  2    4                   Type Definitions--Paragraph #5
ELEM 2    2    1    243  2    5                   An Object Kind used as a Type Table can in turn have a Type Table of its own to form a hierarchy.  As an example, suppose a developer created an Object Kind for living thing kingdoms.  In this table he added plants and animals.  Now suppose he added an Object Kind for animal classes and added mammals and reptiles.  The developer could then specify that the living kingdom table will be the Type Table for the animal class table.  When adding an animal class, the user could then be obliged to categorize the animal class as plant or animal.  To do this, the user would, for example, assign the Type Value animal to the mammal and reptile.  Now suppose the developer creates another Object Kind, this one for animals and specifies that the animal class table is the Type Table of the animals.  The user would then be limited to adding animals of type mammal or type reptile.  If cat was added as an animal it could be given the type value, mammal.  There is an Object Kind called Type Definition Path (Code 56) which is used to record these relationships.  A Type Definition Path has links to Type Definitions.  In this example a Type Definition Path for living thing kingdom for animals would be linked to 1. Animal Class for and Animal 2. living thing Kingdom for an Animal Class.  This can be used to determine that a cat is part of the animal kingdom.  This approach could be extended to model the hierarchy used for classifying animals.
ELEM 2    2    1    450  2    5                   Object Elements are defined as components of an Object.  An Object Element can be compared to a Column or Field of a Table which assigns meaning to a particular set of data.  Object Element Values are typically character data or numeric data stored in fields defined as Object Elements.  Object Element Values are associated with an Object Element and a specific instance of an Object.  Object Element Values are stored in the Table Element identified by Code 31.  Object Elements use Object Kind Code 3.  A list of the Object Elements included in the Base Specification can be found in Appendix 2.  For Object Elements from the Base Specification, the Code shown in Appendix 2 would be populated in Table Element 8.  Table Element 7, Object Element ZTIC, would be populated with the ZT Instance Code that represents the source ZT Instance of the Object Element.
ELEM 2    2    1    450  2    4                   Object Elements--Paragraph #1
ELEM 2    2    1    250  2    4                   Links--Paragraph #2
ELEM 2    2    1    250  2    5                   The Link Value element in Table Element 30 contains a numeric value that can be used to indicate the strength or priority of a link.  If an object is linked to several other objects, the Value can be used to indicate which object has first priority.  It can also be used as a percentage or to indicate relative weight.  Suppose there are links from a person to her favorite songs to be used by an application that plays music.  If one song was most favored the link could be given a value of 100.  A less favored song would be given a value of 10.  If the application was set to random play, the application could be programmed so that the favored song would be played 10 times as often as the less favored song.
ELEM 2    2    1    249  2    4                   Links--Paragraph #1
ELEM 2    2    1    249  2    5                   Typically an object will contain a limited number of elements within its own definition.  To make useful applications, it is often advantageous to create links between the objects.  A Link is used to establish a relationship between one object and another.  Links are attributes of an object, not objects themselves.  The from side of the link uses standard object identifiers of the object containing the link.  The object being linked to is identified by the Link-To Kind ZT Instance Code, Link-To Kind Code, Link-To ZT Instance Code and Link-To Code.  These are stored in Table Elements 19 through 22.  The links that are allowed for a particular object are based on the Object Template being used to maintain or query the object.  Object Templates are explained later in this section of the document.
ELEM 2    2    1    260  2    5                   Link Types contain the rules which determine which links are allowed/required for a particular Technical Profile. Application development requires defining objects and defining the allowed relationships between objects.  Link Types provide one of the tools used for this purpose.
ELEM 2    2    1    260  2    4                   Link Type--Paragraph #8
ELEM 2    2    1    259  2    5                   --moved to link target type heading  DELETE---
ELEM 2    2    1    259  2    4                   Link Type--Paragraph #7
ELEM 2    2    1    258  2    5                   Link Types contain the rules which determine which links are allowed/required for a particular Technical Profile. Application development requires defining objects and defining the allowed relationships between objects.  Link Types provide one of the tools used for this purpose.
ELEM 2    2    1    258  2    4                   Link Type--Paragraph #1
ELEM 2    2    1    257  2    5                   Link Types also specify a usage indicator, to be explained in the section for Link Target Types
ELEM 2    2    1    257  2    4                   Link Type--Paragraph #6
ELEM 2    2    1    256  2    4                   Link Type--Paragraph #5
ELEM 2    2    1    256  2    5                   In addition to the standard Link Type described above, a Link Type can also be of type Composite.  The Composite Link Type makes it possible to combine the characteristics of existing Link Types.  A Link Type of type Composite can be linked to standard Link Types or other Link Types of type Composite.  The Link type of type Composite  uses Operator as a type value to indicate the relationship between the members that are linked to, for example logical AND, logical OR or XOR.  To remove ambiguity  the Link Type of Type Composite and the standard Link Types can only have one parent Composite.   If there is an XOR (exclusive or) relationship it means that only one of the member Link Types can be used. An example where an XOR Link Type could be used is if you have an address that could be linked to a post office box or a street but not to both a post office box and a street.  The min/max specifications of a Composite take precedence over the min/max of the child Link Types.  For example if the maximum for a parent is 2 links and each child specifies a maximum of 3, the 2 takes precedence.  It is illegal for a child a have a minimum value that exceeds the min value for the parent. When links are recorded in the table as a result of message processing, only standard Link Types not Link Types of Type Composite written to the database.
ELEM 2    2    1    255  2    4                   Link Type--Paragraph #4
ELEM 2    2    1    255  2    5                   The Link Type uses an Object Set as a type value.  The Object Set determines allowed objects on the from side of a new link using the Link Type.    Additionally, the Link Type  must specify a Link Target Type as a type value.
ELEM 2    2    1    254  2    4                   Link Type--Paragraph #3
ELEM 2    2    1    254  2    5                   An object that is linked to can in turn be linked to other objects, creating a hierarchy of links.  When an object is queried, the server returns the values of that object plus the values of any objects that are linked to and the the values of any objects that those linked objects are linked to and so on until no more objects are linked.  The link types that are relevant for the objects selected is determined from the object templates specified for the objects being queried.  This will be explained in more detail.
ELEM 2    2    1    253  2    4                   Link Type--Paragraph #2
ELEM 2    2    1    253  2    5                   As a Link Type example, suppose a developer is defining an Object Kind for a person and wants to require that the person is linked to an address.  A Link Type would be added that says the person must be linked to exactly 1 (minimum 1, maximum 1) address.  The Link Type description could be i.e. Link from person to address.  If a client application then tries to create a person that is not linked to a an address, the message would be rejected.  As another example, suppose that a Link Type is being created for links from a financial document to the line items of the financial document.  The minimum and maximum on the source side specifies how many children the source of the link may/must have.  This could be minimum of 1 and maximum of 10,000.  This indicates that the financial document must have at least 1  but no more than 10,000 line items.
ELEM 2    2    1    252  2    4                   Link Type--Paragraph #1
ELEM 2    2    1    252  2    5                   Link Types along with the Link Target Type contain the rules which determine which links are allowed/required for a particular Technical Profile invoked by an Object Template.   Application development requires defining Object Templates which define the allowed relationships between objects.  Link Types provide one of the tools used for this purpose.  A list of the Link Types from the Base Specification can be found in Appendix 4.
ELEM 2    2    1    266  2    5                   Type 2 (Role may be used) could be used, for example, for links from an Greeting Card List to persons.  You may want to link to actual persons such as Kate and Larry but you may also want to refer to some persons by their role such as President or Treasurer.  When processing the person(s) assigned to the role would replace the role.
ELEM 2    2    1    266  2    4                   Link Target Type--Paragraph #5
ELEM 2    2    1    265  2    5                   Link Types and Link Target Type have three usage indicator values one for Roles  that dictate how links that use the Link Target Type refer to objects.  1=Standard no usage of Roles, 2=Roles may be used. 3=Roles must be used to refer to objects.
ELEM 2    2    1    265  2    4                   Link Target Type--Paragraph #4
ELEM 2    2    1    264  2    4                   Link Target Type--Paragraph #3
ELEM 2    2    1    264  2    5                   Similar to the Link Type, the Link Target Type includes elements that contain minimum and maximum number of links for source and target that can use the Link Target Type.  A Link Target Type with minimum of 1 and a maximum of 1 has the effect of an exclusive logical OR relationship.
ELEM 2    2    1    263  2    4                   Link Target Type--Paragraph #2
ELEM 2    2    1    263  2    5                   The Link Target Type uses a Object Set as a type value.  The Object Set determines valid objects to be linked to.  The Link Target Type is linked to Object Templates that will be applied to objects being linked to.  A validation rule applied to the Link Target Type ensures that the Object Templates linked to have one and only one Object Template per Object Kind.  This is to remove any ambiguity as to which Object Template should be applied to an Object of a specific Kind that is a target of a link.
ELEM 2    2    1    262  2    4                   Link Target Type--Paragraph #1
ELEM 2    2    1    262  2    5                   The Link Target Type is used to organize a set of potential targets for the links that use a particular Link Type.  The minimum and maximum on the target side specifies how many parents the child can have using this link type.  In the financial document example, the minimum could be 1 and the maximum could be 1.  The line item must have at least 1 parent meaning it cannot exist in isolation (without a parent financial document).  The maximum of 1 indicates that it can have only 1 parent financial document.  This is to prevent two financial documents from including the same line item.  Recall that the min/max on the source side is contained in the Link Type while the min/max on target side is specified in the Link Target Type.  In the Base Specification there is a Link Target Type using a Code that corresponds to the Codes used for the Link Types listed in Appendix 4.  The Link Types use Object Kind 10 and the Link Target Types use Object Kind Code 11.  Each Link Type specifies the corresponding Link Target Type as a Type Value using Type Definition 2.
ELEM 2    2    1    267  2    4                   Link Target Type--Paragraph #6
ELEM 2    2    1    267  2    5                   Type 3 (Role must be used) could be used when you want the role to be the only way of referring to the person.  For example to link from the president to the secret defense plan.
ELEM 2    2    1    268  2    4                   Link Target Type--Paragraph #7
ELEM 2    2    1    268  2    5                   The usage indicators of the Link Type and Link Target Type are used to determine how a link that specifies the Link Type and Link Target Type are treated.  With usage Type 2 or 3 a link to a Role would not be treated as a link to the Role but rather a link to the holder of the Role.  Roles are explained later in more detail.
ELEM 2    2    1    269  2    4                   Link Target Type--Paragraph #8
ELEM 2    2    1    269  2    5                   A Link Target Type can be linked to a validation function that ensures that the type value used for the link target is the same as the type value used on the link source.  As an example, assume an object is created for address.  The type table for the address is country.  In defining the address we also want to link to a state/province which also uses the country table as a type table.  The validation function enforces that addresses of type USA will be linked to a state/province also of type USA.
ELEM 2    2    1    270  2    4                   Link Target Type--Paragraph #9
ELEM 2    2    1    270  2    5                   Two Link Target Types that have the same parent Link Type can be related in a way to ensure that the type value for a link target is taken from the other link target.  As an example, assume an   Address is linked to a state/province and a postal code.  The postal code uses state/province as its type table.  The system should check that postal code linked to uses as its type value the state/province linked to.  This  is designated by a link from the one Link Target Type (the postal code in this example) to the Link Target Type that will handle links to the type value (state/province in this example.  It is enforced with a validation routine.
ELEM 2    2    1    281  2    5                   The membership specified is additive.  For example if a set is linked to some object to include them as members and it is also linked to a type definition so that all objects of that type are included then the set will include members based on all linkages.  Any duplication of the members specified would be ignored and each object would appear as a member only once.
ELEM 2    2    1    281  2    4                   Object Sets--Paragraph #10
ELEM 2    2    1    280  2    5                   When a server determines the members of a set, it must include with each member the timestamp range when the membership is effective.  When returning the members of a set the server needs to base this on a specific point in time.  Only members that are effective at that point in time are relevant when determining membership.  The point in time used for this purpose will generally be the effective time of the top level object being queried or maintained.
ELEM 2    2    1    280  2    4                   Object Sets--Paragraph #9
ELEM 2    2    1    279  2    5                   If an Object Set of type Standard is linked to an Object Set of type Composite, any members of the composite set that are not of the same kind as the type value of the Object Set of type standard are ignored (will not be considered members).
ELEM 2    2    1    279  2    4                   Object Sets--Paragraph #8
ELEM 2    2    1    278  2    5                   An Object Set of type composite can only be linked to other Object Sets.  This includes Object Sets of type Object Set Type:Standard, Object Set Type: Composite, Object Set Type: Negate and Object Set Type: Universal
ELEM 2    2    1    278  2    4                   Object Sets--Paragraph #7
ELEM 2    2    1    277  2    5                   An Object Set of type Negate acts to take all the Objects in the Set and removes them, if present, from the Set that is the immediate parent of the Negated set.  An Object Set of type Universal represents the set of all objects in a DS Instance.  It would presumably be linked either to a set of type Negate or to nothing at all.
ELEM 2    2    1    277  2    4                   Object Sets--Paragraph #6
ELEM 2    2    1    276  2    5                   The link to a Type Definition can also be to a Type Definition that is further up the type hierarchy. For example if there is an object kind for animals including lions, tigers, cheetahs, wolves, bears, fish and lobsters.  A type table could include cats, non-cats and sea creatures.  A type table for that could include mamals and non-mamals.  The Set could be linked to the Type Definition that includes the mamals and non-mamals and select the type values mamals. This would cause the animals lions, tigers, cheetahs, wolves and bears to be included as set members.
ELEM 2    2    1    276  2    4                   Object Sets--Paragraph #5
ELEM 2    2    1    275  2    5                   Another way to specify the members of an Object Set of type standard is to link to a Type Definition and also link to a Set that has type values to be included.  This will cause all objects with the selected type values that are valid for that Type Definition to be included in members.  For example a standard set of type person could be linked to a type definition called gender which has possible type values of male, female and hermaphrodite.  It could also be linked to a set of type values to be included which contains  male and hermaphrodite.  The end result is that the set of Persons would include Persons with gender:male or gender:hermaphrodite.
ELEM 2    2    1    275  2    4                   Object Sets--Paragraph #4
ELEM 2    2    1    274  2    5                   As an example use for an Object Set, suppose an Object Set is linked to Object Kind Person and that Object Set acts as a type value for a Link Type, it would mean that the Link Type would  permit links on the From side of the link that are persons.
ELEM 2    2    1    274  2    4                   Object Sets--Paragraph #3
ELEM 2    2    1    273  2    5                   The members of an Object Set are determined based on links from the Object Set Definition to other Objects using a variety of Link Types.  An Object Set that is not linked to any object is the empty set.  The possible Link Types to determine Set membership are listed below.  The Link Type Codes refer to the list of Link Types in the Base Specification found in Appendix 4.
ELEM 2    2    1    273  2    4                   Object Sets--Paragraph #2
TYPE 2    2    1    273  2    2    2    3              
LINK 2    2    1    273  2    2    2    2    1    455                           5179248000.000      9000 
LINK 2    2    1    273  2    2    2    2    1    456                           5179248000.000      10000
LINK 2    2    1    273  2    2    2    2    1    457                           5179248000.000      8000 
LINK 2    2    1    273  2    2    2    2    1    458                           5179248000.000      7000 
LINK 2    2    1    273  2    2    2    2    1    459                           5179248000.000      6000 
LINK 2    2    1    273  2    2    2    2    1    460                           5179248000.000      5000 
LINK 2    2    1    273  2    2    2    2    1    462                           5179248000.000      3000 
LINK 2    2    1    273  2    2    2    2    1    463                           5179248000.000      2000 
LINK 2    2    1    273  2    2    2    2    1    464                           5179248000.000      1000 
LINK 2    2    1    273  2    2    2    2    1    465                           5179248000.000      900  
LINK 2    2    1    273  2    2    2    2    1    461                           5179248000.000      4000 
LINK 2    2    1    273  2    2    2    2    1    466                           5179248000.000      800  
LINK 2    2    1    273  2    2    2    2    1    560                           5179248000.000      700  
ELEM 2    2    1    272  2    5                   A Object Set is used to specify the members of a group of objects out of a possible universe of all objects of all kinds in a ZT instance.  It is used, for example, by Link Types and Link Target Types to determine which objects would be valid as the source or target of a link.  Sets can also be used for query selection.  For each Object Kind listed in Appendix 1 the Base Specification has a Object Set with the same code.  These sets contain all of the objects of the corresponding Object Kind.  The descriptions are the same except that they all begin with the words "Set of all" and the words (Object Kind) are removed.  Object Sets use Object Kind 13.
ELEM 2    2    1    272  2    4                   Object Sets--Paragraph #1
ELEM 2    2    1    283  2    5                   Object Templates control access to the attributes of an object, namely the Object Element values, Type values and links.  When an Object Template is maintained, links are created from the Object Template to Technical Profiles using Link Type code 1.  The Technical Profiles are in turn linked to Object Elements, Type Definitions and Link Types that are invoked when an object is maintained using the Object Template.  When an object is maintained or queried, the Object Template to be used is specified.  This determines which attributes can be maintained or queried.  A given object can utilize multiple Object Templates. The Object Templates can be used to express alternative usages for an object.  For example, if the object kind were company, there could be an Object Template for customer and another Object Template for vendor.  Each template would contain the attributes relevant to a particular usage via the linked Technical Profiles.  It would be possible for a company to be both a customer and a vendor.  This could be handled by maintaining the company twice, once with the Object Template for customer and once with the Object Template for vendor.  Object Templates use an Object Kind as a type value to indicate which Object Kind the template will be used for.  For each Object Kind listed in Appendix 1 the Base Specification has an Object Template with the same code.  The descriptions are the same except that instead of ending with (Object Kind) they end with (Base Template).  Object Kinds use Object Kind 1 and Object Templates use Object Kind 2.
ELEM 2    2    1    283  2    4                   Object Template--Paragraph #1
ELEM 2    2    1    284  2    5                   When a message is processed to maintain an object using a particular Object Template, the ZTIC (ZT instance code) and Code of that template are recorded with the attributes of that object.  Any subsequent query of that object would be done with respect to one of the recorded templates.
ELEM 2    2    1    284  2    4                   Object Template--Paragraph #2
ELEM 2    2    1    285  2    5                   An Object Template can refer to another Object Template as a reference using Type Definition with Code 30.  In this case the referencing Object Template inherits the attributes of the referenced Object Template.  For example, there could be a template for Object Kind, company called specialized customer that references the template for generic customer.  The specialized customer would inherit all of the attributes of generic customer and possibly add some of its own.  A query of generic customers could also select companies that were only maintained using the Object Template for specialized customer because the specialized customer Object Template references the generic customer Object Template.
ELEM 2    2    1    285  2    4                   Object Template--Paragraph #3
ELEM 2    2    1    288  2    5                   Technical Profiles are invoked during message processing based on the Object Template specified in the message for an object to be maintained or queried.  Any attribute definition (Object Element, Type Definitions or Link Type) that has been linked to from a Technical Profile that has been linked to from the Object Template being processed, is determined to be relevant.  If an attribute definition is determined to be relevant, then the server allows the related attribute (Object Element values, Type values or links) to be maintained or queried.  For Type Definitions and Link Types, the other requirement is that the objects referred to are members of the Object Set used as a type value for the Type Definition or Link Type being evaluated.  If it is not, the Type Definition or Link Type is ignored and is determined to be not relevant.  If a Link Type is determined to be relevant, the rules specified for the Link Type are applied.  For example, minimum and maximum number of links must the satisfied for a Link Type.  To determine if the rules are being followed in the case of a Link Type, it is necessary to consider not only links specified in the message, but also links that already exist in the database.
ELEM 2    2    1    288  2    4                   Technical Profile--Paragraph #2
ELEM 2    2    1    287  2    4                   Technical Profile--Paragraph #1
ELEM 2    2    1    287  2    5                   Technical Profiles can linked to Object Elements, Type Definitions and Link Types using Link Types with codes 3, 4, and 5, to make them relevant for Object Templates that are linked to the Technical Profile.  The Technical Profile can be linked to other Technical Profiles using Link Type with code 2.  A  Technical Profile that is linked to another Technical Profile inherits the links to the Object Elements, Type Definitions and Link Types of the Technical Profile it is linked to.  A Technical Profile can also be linked, using Link Type with code 25, to another Technical Profile to suppress attributes included in the target Technical Profile from the source Technical Profile.  Technical Profiles are designed to encourage re-use of the configuration for Object Templates.  Configuration that is likely to be shared by multiple Object Templates can grouped into a single Technical Profile and be utilized by multiple Object Templates.  For each Object Kind listed in Appendix 1 the Base Specification has a Technical Profile with the same code.  The descriptions are the same except that instead of ending with (Object Kind) they end with (Technical Profile).  Technical Profiles use Object Kind 12.  In addition to the description attribute, each Technical Profile is linked, using Link Type 3 to an corresponding Object Element that hold the description for each Object Kind.  For example, Technical Profile 9 is linked to Objecct Element 9 to hold the description for Type Definitions.
ELEM 2    2    1    290  2    4                   Type Based Template Rule--Paragraph #1
ELEM 2    2    1    290  2    5                   The Type Value Based Template Rule is used to invoke Object Elements, Type Definitions and Link Types for an Object Template based on the Type Value an object has.  Objects with Type Values that have similar characteristics can share a Type Value Based Template Rule.  Specialized characteristics can also be added using a Type Value Based Template Rule that is unique to a single Type Value.  In many cases, the Object Template will be sufficient.  The Type Value Based Template Rule is only needed if specialized behavior is needed based on the Type Value of an object.  Type Value Based Template Rules use Object Kind Code 5.
ELEM 2    2    1    291  2    4                   Type Based Template Rule--Paragraph #2
ELEM 2    2    1    291  2    5                   To use a Type Value Based Template Rule a link is created from a Type Definition to the Type Value Base Template Rule using Link Type Code 29.  The Type Definition linked to the Type Value Based Template Rule is invoked based on a link from a Technical Profile that is linked to from a Object Template being processed.  The Type Value Based Template Rule uses an Object Set as a type value with Type Definition 39.  The Object Set members are used to specify all the type values that will have the special attributes determined by the Type Value Based Template Rule such as Object Elements, Type Definitions and Link Types.  The Type Based Template Rule also uses Object Template as a type value with Type Definition 38. The Object Template used as a type value is linked to the Object Elements, Type Definitions and Link Types that will be invoked if an object is created with a type value that is included in the Object Set of type values used by the Type Value Based Template Rule.  Care should be taken to ensure that there are not over-lapping type values in the Object Sets if a Type Definition is linked to multiple Type Value Based Template Rules.
ELEM 2    2    1    292  2    4                   Type Based Template Rule--Paragraph #3
ELEM 2    2    1    292  2    5                   As an example of how the Type Value Based Template Rule could be used, suppose that an object definition is being created for Address.  The Object Template for the Address is linked to a Technical Profile which is linked to the Object Elements that will contain values for the address such as city, street and house number etc.  The Technical Profile is also linked to a Type Definition that specifies that Country will be a type table for Address.  We would also like to include an Object Element for postal code, but different countries use the postal code differently and some countries use no postal code at all.  To solve this, a Type Value Based Template Rule can be used.  This Type Value Based Template Rule specifies an Object Template as a type value that is linked to an Object Element that has the correct specification for postal code that is used for a set of countries.  The Type Definition, Country for Address is linked to several Type Value Based Template Rules. To specify which countries each Type Value Based Template Rule applies to, each Type Value Based Template Rule uses an Object Set that includes the relevant countries as members as a type value.  Using this configuration the ZT Server can determine the appropriate postal code Object Element to use for the address within a country if that country uses postal codes.
ELEM 2    2    1    294  2    4                   Link Based Template Rule--Paragraph #1
ELEM 2    2    1    294  2    5                   The Link Based Template Rule can be used to specify specialized behavior based on which links exist for a Link Type.  It follows he same general pattern as the Type Value Based Template Rule.  Link Based Template Rules use Object Kind Code 6.
ELEM 2    2    1    487  2    5                   To use a Link Based Template Rule a link is created from a Link Type to the Link Base Template Rule using Link Type Code 33. The Link Type linked to the Link Based Template Rule is invoked based on a link from a Technical Profile that is linked to from a Object Template being processed. The Link Based Template Rule uses a Object Set as a type value using Type Definition Code 44. Object Set specifies all the objects that can be linked to, to invoke the specialized attributes such as Object Elements, Type Definitions and Link Types. The Link Based Template Rule used Object Template as Type Value, using Type Definition 43, which is linked through Technical Profiles to the Object Elements, Type Definitions and Link Types that will be invoked if an object is created that is linked to an object that is included in the Object Set used by the Link Based Template Rule.
ELEM 2    2    1    487  2    4                   Link Based Template Rule--Paragraph #2
ELEM 2    2    1    296  2    4                   Object Element Value Based Template Rule--Paragraph #1
ELEM 2    2    1    296  2    5                   The Object Element Value Based Template Rule is used to specify specialized behavior based on how an Object Element has been populated.  Object Element Value Based Template Rules use Object Kind Code 7.  To use an Object Element Value Based Template Rule a link is created from an Object Element to the Object Element Value Based Template Rule using Link Type Code 34. It follows a similar pattern as the Type Value Based Template Rule and the Link Based Template Rule in that it uses Object Template as a type value, using Type Definition Code 45, which through the Technical Profile is linked to Object Elements, Type Definitions and Link Types to be invoked.  The Object Element Value Based Template Rule uses an Object Set as a type value, using Type Definition Code 46 and Object Element as a type value using Type Definition Code 47.  These two type value determine which objects and which Object Elements in those objects to look for a match with the Object Element using the Object Element Value Template Rule.  If a match is found, the Object Element Value Template Rule is invoked.  An example usage would be if an Object Element could be configured with a Object Element Value Template Rule so that if a boolean value of the Object Element is set to true, then additional Object Elements are required to be populated when maintaining an object being created using a Template with an Object Element that includes the rule.
ELEM 2    2    1    298  2    5                   Extended Key Definitions are used to configure Object Elements that are accessed using key values beyond the Object Code ZTIC and Object Code.   For example language (human) has an Extended Key Definition as part of the base specification.  The base template for Extended Key Definition for language uses a Type Definition where Language is specified as the type table and the Set of all languages are allowed values.  Fiscal period is an other example of a possible  extended key.
ELEM 2    2    1    298  2    4                   Extended Key Definition--Paragraph #1
ELEM 2    2    1    300  2    4                   Roles--Paragraph #1
ELEM 2    2    1    300  2    5                   The idea behind a Role is that it makes it possible to instantly activate a set of Link Types by simply assigning an Object, for example a Person, to a Role.  Roles could be used for persons or for a variety of object kinds.  For example an chemical could serve the role of a catalyst or a vehicle could fill the role of a school bus. Roles can be linked to from an Object Set to help determine the members of the Set.  Object Kind serves as the type table for Role.  Links are created from a Role to to objects that are  of the Kind that are the type of the Role.
ELEM 2    2    1    301  2    4                   Roles--Paragraph #2
ELEM 2    2    1    301  2    5                   For example, there could be a Role of type Person.  A link is created from the Role, for example  President, to a Person that fills that role.  The link type for this link  would be invoked (become relevant) if a Person  being maintained  is linked to from the Role i.e.  President and that Role is linked to from the Object Set that is a type value for the Link Type (meaning that holders of the role are members of the Object Set tied to the link type in question).  Links refer to the holders of a Role based on a code usage indicator in the Link Type . The Links that are expanded by referring to persons that are holders of roles must  still conform to the rules of the Link Type. If a role is maintained, i.e. assigned to additional persons, the system must perform a validation to make sure that this will not cause some links to violate the rules of the link type.   Roles can be linked to other Roles to form a Role Hierarchy.  If a Link Type specifies a Role the system will look higher up the hierarchy to see if the person being maintained is assigned to that role.
ELEM 2    2    1    311  2    5                   Conditional values can serve as the type table for Link Types and Link Target Types.  If the function associated with the conditional value returns a false, all of the links associated with the Link Type or the Link Target Type are suppressed.
ELEM 2    2    1    311  2    4                   Software Modules--Paragraph #9
ELEM 2    2    1    303  2    4                   Function Group--Paragraph #1
ELEM 2    2    1    303  2    5                   Function Groups are used to organize a set of functionality that can be called in a generic manner.  Function Groups can be linked to one or more Functions that are to be executed and one or more System Messages that provide the boilerplate text to be added as log messages.  The Function Group calls each Function and possibly replaces portions of boilerplate system messages with variable values.  One important use for Function Groups is for validations.  The Function Group can be used to analyze an incoming message, do a validation check, add appropriate log messages and set the status of message, for example to indicate that the validation failed.
ELEM 2    2    1    304  2    4                   Software Modules--Paragraph #2
ELEM 2    2    1    304  2    5                   The Function Group (Object Kind Code 52) is linked to System Messages (Object Kind Code 24) using Link Type Code 31 and Functions (Object Kind Code 36) using Link Type 32.  The function is linked to a set of parameters (using Link Type Code 8).    The Function Group handles populating parameters that will be used by the functions.  The Function Group includes an Object Element that can be populated with a start parameter.  This can be used in a variety of ways including being used to determine the choreography of Functions to be called.  By default each function is called once based on the link value of the links from the Function Group to the Functions with the links with the high values being called first.
ELEM 2    2    1    306  2    4                   Software Modules--Paragraph #4
ELEM 2    2    1    306  2    5                   -
ELEM 2    2    1    305  2    5                   An example of how a Function Group can be used is the Function Group with code 2 in the validation namespace, outside of the base specification.  This is used to validate that that if an object is being maintained with links to existing objects that the objects being linked to actually exist in the database.  Function with Code 2, in the validation namespace was created to perform the validation.  System message with Code 2, in the validation namespace was added to provide a message that can be logged if the validation fails.
ELEM 2    2    1    305  2    4                   Software Modules--Paragraph #3
ELEM 2    2    1    307  2    4                   Software Modules--Paragraph #5
ELEM 2    2    1    307  2    5                   -
ELEM 2    2    1    308  2    5                   -
ELEM 2    2    1    308  2    4                   Software Modules--Paragraph #6
ELEM 2    2    1    309  2    5                   -
ELEM 2    2    1    309  2    4                   Software Modules--Paragraph #7
ELEM 2    2    1    310  2    5                   Note:  The Conditional Values are processed in order of precedence.  The first Conditional Value that evaluates as true would be utilized and the rest ignored. In the case of incest which causes a brother and a nephew to be the same person only the first Conditional Value that evaluates as true would be used.
ELEM 2    2    1    310  2    4                   Software Modules--Paragraph #8
ELEM 2    2    1    312  2    5                   -
ELEM 2    2    1    312  2    4                   Software Modules--Paragraph #10
ELEM 2    2    1    313  2    5                   A possible elaboration would be to permit the Conditional Values to be linked not only to an Object Element containing fixed values but also to a function that returns a value at runtime if the boolean expression for that Conditional Value is determined to be true.
ELEM 2    2    1    313  2    4                   Software Modules--Paragraph #11
ELEM 2    2    1    315  2    5                   As an object is maintained through time, the ZT Server retains the various versions of the object attributes.  The standard key includes a time stamp, in Table Element 26,  which is used to maintain the multiple versions.  To illustrate usage of the timestamp, assume an example sales order application.  Typically a sales order application would use master data, for example, the customer master and item master.  These are used to build the transactional data, the sales order.  The example assumes a simplified set of master data and a sales order shown below.
ELEM 2    2    1    315  2    4                   Rationale and Approach to Versioning--Paragraph #1
LINK 2    2    1    315  2    4    6    1    1    1002                          5179248000.000           
ELEM 2    2    1    435  2    5                   The sales order shown includes only one line-item.  The master data objects are referred to in the sales order using their key, 1 for customer (ABC Co.) and 10 for item master (Bananas).
ELEM 2    2    1    435  2    4                   Rationale and Approach to Versioning--Paragraph #2
ELEM 2    2    1    436  2    5                   The difficulty arises when there is a change to the master data.  Suppose the customer changed their name from ABC Co. to DEF Co. and this is changed in the customer master.  If someone displays the sales order, it will show that the Sale was from DEF Co. even though it was originally created for ABC Co.  This may be okay in some cases and in others may cause confusion.
ELEM 2    2    1    436  2    4                   Rationale and Approach to Versioning--Paragraph #3
ELEM 2    2    1    437  2    5                   One way to remedy this problem is to copy the customer name into the sales order.  Since the item master has a similar problem, we could also copy in the item description as below.
ELEM 2    2    1    437  2    4                   Rationale and Approach to Versioning--Paragraph #4
LINK 2    2    1    437  2    4    6    1    1    1003                          5179248000.000           
ELEM 2    2    1    438  2    5                   Of course, There is more in the customer master than the customer name.  Any of these elements such as customer telephone number and customer address and customer contact person could change over time.  To have a true picture of what these values were at the time the order was created, it would be necessary to copy all of the master data into the sales order.  To ensure a consistent truth throughout the system it would also be necessary to protect that master data values in the sales orders from changes.  Generally applications take a hybrid approach, copying in some elements from the master data into the transactional data and accepting a level of data inconsistency across the system.
ELEM 2    2    1    438  2    4                   Rationale and Approach to Versioning--Paragraph #5
ELEM 2    2    1    439  2    5                   The ZT server uses a key with a timestamp to record when a value became effective. Links are created from objects to other objects so they can relate to the correct version of the object linked to at the time the link was created.  For example, when the customer name changes, this is reflected with a second record with the new name and a timestamp that indicates when the change is effective.
ELEM 2    2    1    439  2    4                   Rationale and Approach to Versioning--Paragraph #6
LINK 2    2    1    439  2    4    6    1    1    1004                          5179248000.000           
ELEM 2    2    1    440  2    5                   By using timestamps with links and Type Values, the ZT Server can access the version of the master data that existed at the time the sales order was created, even if the master data subsequently changed.  This is a simplified example.  A Sales Order design would more likely contain a header linked to line items with other objects related by some combination of Links and Type Values.
ELEM 2    2    1    440  2    4                   Rationale and Approach to Versioning--Paragraph #7
ELEM 2    2    1    445  2    5                   This illustrates how objects from different sources can maintain their uniqueness in the same table.  The actual namespaces could be based on a URL to guarantee uniqueness across ZT instances.   The ZT Instance table provides cross-reference between the ZT Instance  code and the actual namespace.   Records in other tables in the database (other than the ZT Instance table)  use the ZT Instance Code (ZTIC) instead of the actual namespace.  When a message is sent between client and server it includes a cross reference between the namespace and the Code used to represent it in the message.  When the server receives a message requesting an insert containing a namespace, it checks the ZT Instance table to see if the namespace exists.  If it does not exist, the new namespace can be added along with a cross-reference to its namespace.  The server finds the ZT Instance code that represents the namespace and uses that to store the record.  Two ZT servers could use the same code internally to represent different namespace.  This is not a problem because any time the data is converted to a message to be used externally, the namespace in its appropriate long form is declared in the message.
ELEM 2    2    1    445  2    4                   ZT Instances--Paragraph #10
ELEM 2    2    1    317  2    4                   ZT Instances--Paragraph #1
ELEM 2    2    1    317  2    5                   The ZT Instance represents a distinct occurrence of an environment for storing data in a ZT Server.  A ZT Client specifies the target ZT Instance when sending a message to the Server.  A user, logging in through a Client, would typically interact with only one ZT Instance per login session.   The application data for the two ZT Instances would be completely separated.
ELEM 2    2    1    318  2    5                   The ZT Instance Code (ZTIC) elements are used to identify a ZT Instance and indicate the source of an object within a ZT Instance.  They are included so that objects from different sources can have the same Kind Code or Object Code value and still have unique identifiers. Each ZT Instance represents its own environment for assigning ZT Instance codes.  Also each message will contain its own environment for assigning codes to ZT instances.  The ZT Instance Code used to represent the local instance within a ZT Instance can have any value but by convention will use the value 1 (the first ZT instance to be declared within a new ZT instance).  ZT instance code 2 by convention represents objects of the Base Specification.  Other ZT Instance Codes can have any other value.  Within each environment the ZT instance Codes will be associated with a namespace that must NOT be changed after it is assigned and used to send data to other systems.
ELEM 2    2    1    318  2    4                   ZT Instances--Paragraph #2
ELEM 2    2    1    319  2    4                   DS Instances--Paragraph #3
ELEM 2    2    1    319  2    5                   DS instance codes are unique only within the context of the DS instance or within a message.  Namespaces must be universally unique to avoid naming conflicts when data is shared among DS instances.
ELEM 2    2    1    320  2    5                   ZT Instance Codes (ZTIC) are unique only within the context of the ZT Instance or within a message.  Namespaces must be universally unique to avoid naming conflicts when data is shared among ZT instances.  When a message is processed, the server must take care of converting from the ZT Instance Codes within the message to the ZT Instance Codes used in the target server by using the namespaces associated with the ZT Instance Codes.  A namespace is designed to be a set of characters that is unique from any other namespace.  To ensure uniqueness it is generally recommended to include an Internet domain name in the namespace.  An example namespace could be my_email_address@a_domain_name.com/my_test_system1.
ELEM 2    2    1    320  2    4                   ZT Instances--Paragraph #4
ELEM 2    2    1    321  2    4                   DS Instance--Paragraph #5
ELEM 2    2    1    321  2    5                   When two ZT Instances share the same Server database tables, they are differentiated using the Server DB--ZT Instance ID, Table Element 32.  Each Server DB--ZT Instance ID is associated with exactly one namespace.  The Server DB--ZT Instance ID does not need to be universally unique, only unique within a Server database.  For example, two servers could use the Server DB--ZT Instance ID called TEST, but they would be differentiated by using unique namespaces, for example dev1.com/test_env and dev2.com/testing_place.  The calling client only needs to specify the namespace of the target ZT Instance in the message and there is no particular need for the client to be aware of the Server DB--Instance ID.  The message and message response only refers to namespaces and related ZT Instance Codes.  The ZT Instance Codes along with the namespaces make it possible to distribute data from one ZT Instance to another without naming collisions.  The following example illustrates the usage of ZT Instance Codes.
ELEM 2    2    1    442  2    4                   ZT Instance--Paragraph #7
ELEM 2    2    1    442  2    5                   A second developer, developer #2, imports the objects from developer #1 and adds some Food Types, for cat and dog foods.  Notice that the ZT Instance code (ZTIC) for the objects imported from developer #1 is different than it was on the first server (101 instead of 1), but the code still represents the same namespace (dev1.com).  The new Food Types are created under the local ZT Instance labeled 1.  Developer #2 adds foods for humans, cats and dogs. He also translates the object kind to Spanish.  The Code and Code ZTIC for the Spanish translation in the Kind table are the same as the English name.  They both have the Code ZTIC 101 to represent the namespace of the original developer (dev1.com).  The Modifier ZT Instance Code indicates which ZTIC a change to an object originated from.  The MZTIC (modifier ZTIC) is 1 to represent dev2.com because developer #2 modified an object that was created by developer #1.
LINK 2    2    1    442  2    4    6    1    1    1006                          5179248000.000           
ELEM 2    2    1    443  2    4                   DS Instances--Paragraph #8
ELEM 2    2    1    443  2    5                   Note:  The food table has duplicate codes in it, but these are differentiated by the ZT Instance Codes (ZTIC).  Also the Food Type T1 is used to represent human food (from developer #1) and cat food (from developer #2).  These are differentiated by the Type Value ZTIC, 101 for developer #1 and 1 for developer #2.
ELEM 2    2    1    444  2    4                   DS Instances--Paragraph #9
ELEM 2    2    1    444  2    5                   A third developer, developer #3, receives the objects from developer #2 and imports them into a 3rd ZT Instance and adds a Food Type for bird food, the foods Bird Seed, Bird Feed, Rice, Tofu and Beans under the ZT Instance Code 1.  Each of these foods is given its code sequentially starting from 1.  The table entries for developer #3 would appear as follows.
LINK 2    2    1    444  2    4    6    1    1    1007                          5179248000.000           
ELEM 2    2    1    446  2    4                   ZT Instances--Paragraph #12
ELEM 2    2    1    446  2    5                   Note:  There is significant reuse of constructs within the specification.  This tends to blur the distinctions between system definition, application development, configuration, master data and transactional data.  The use of separate ZT Instances can help clarify this.  For example, development and configuration could occur in a separate ZT Instances (ZTI).  When development and configuration is completed it can be transferred to another ZTI for testing and/or transactional postings.  The transferred objects retain the namespace of the source ZTI where they were created.  This makes them identifiable if they need to be removed.
ELEM 2    2    1    454  2    4                   ZT Instances--Paragraph #11
ELEM 2    2    1    454  2    5                   The pattern described here could be extended to enrich the application further.  For example, a fourth developer could decide to build an application for handling recipes that includes the possibility of creating links to the foods depicted here as ingredients.  It would also need to include quantities, units of measure and cooking instructions.  A fifth developer could then use the recipe application to build a recipe book that allows the possibility for the recipe book to create links to recipes.  It was mentioned that developers can distribute their work to other developers.  To achieve this, is is necessary to have a client application that queries a ZT Instance and maps the Response to the Request of a new message.  The new message can then be imported by others.
ELEM 2    2    1    441  2    4                   ZT Instance--Paragraph #6
ELEM 2    2    1    441  2    5                   This example shows how data from several ZT Instances can be used to enrich an application.  For this example, suppose a developer wants to create a ZT Object Kind for storing food data with some useful attributes such as name and calories per kilogram. The ZT Instance that the developer is working in is associated with namespace dev1.com and ZT instance code 1 (the local instance).  The developer creates an Object Kind for food and creates the foods Bread and Lettuce.  The developer also creates an Object Kind for Food Type and adds an entry for Human Food.  Table entries are shown below.  Some elements are omitted to simplify the example.  Also, language dependent and language independent rows are presented as a composite in the same table row.  In actual practice they could be stored in separate tables.  In the composite views, language dependent entries that appear for multiple languages have repeated rows.
LINK 2    2    1    441  2    4    6    1    1    1005                          5179248000.000           
ELEM 2    2    1    328  2    5                   This section describes the Object Kinds, Links and Type Definitions used to define how Object Element data can be stored on a ZT Server. These are use to validate data in a Request Message.
ELEM 2    2    1    328  2    4                   Defining Meta-Data Introduction--Paragraph #1
ELEM 2    2    1    337  2    5                   Object elements are used to declare the data components of an Object Kind.   Links are created from a Technical Profiles to the Object Elements to determine if the Object Elements are relevant for the Object Templates that use the Technical Profile. The Object Element has two type tables, Object Element Usage Type and Data Element.
ELEM 2    2    1    337  2    4                   Object Element--Paragraph #1
ELEM 2    2    1    338  2    5                   The Object Element Usage type serves as one of the Type Tables for Object Elements.  There are two possible values of Object Element Usage Type, Standard and External.
ELEM 2    2    1    338  2    4                   Object Element Usage Type--Paragraph #1
ELEM 2    2    1    339  2    5                   Object Elements of type external are linked to another Object Element of type internal which will be the source of the value for Object Element.  There is also a link from the Object Element to a Link Type.  A link of the specified type must be created from a newly create object (that uses an object element of type external) to an object that will provide the value for the object element with a type of external.
ELEM 2    2    1    339  2    4                   Object Element Usage Type--Paragraph #2
ELEM 2    2    1    340  2    5                   An example usage could be an international shipping document that has a country of origin and a destination country.  If the desire is to include the names of the countries in the shipping documents there could be two external elements, one for country of origin and another for destination country.  There would need to be two Link Types, one to handle the link from the shipping document to the country of origin and another to link the shipping document to a destination country.  For a given shipping document there would need to be links to these countries so that the values for the country names could be captured and returned with the shipping document.  It is possible that a link type would allow multiple links of that type to be created.  In this case the the element of type external would take its value from the object that is linked to with the highest link value.
ELEM 2    2    1    340  2    4                   Object Element Usage Type--Paragraph #3
ELEM 2    2    1    341  2    5                   An Object Element of Object Element Usage Type External gets its value from a related type table.  There must be a link from the Object Element (of type external) to the Object Element (of type Standard) where the Object Element value will be pulled from.  Also External Object Element would use Type Definition Path as a type value which would have a link to the Type Definition used to find the internal object element value. An example of this could the an address that uses country as a type table.  The name of the country is part of the address but it is included with the Country Object Kind as an Standard Object Element.  To configure this, country name would be added to the address as an external object element.  There would be link from this country name object element to the Standard Object Element for country name used by the Country object kind.  The External Object Element would use a Type Definition Path as a type value which would be linked to the type definition, country for address.
ELEM 2    2    1    341  2    4                   Object Element Usage Type--Paragraph #4
ELEM 2    2    1    343  2    5                   -
ELEM 2    2    1    343  2    4                   Object Element Usage Type--Paragraph #6
ELEM 2    2    1    342  2    5                   This same approach can be used to include values that are higher up the type table hierarchy.  For example, suppose there was a wish to include Continent name as part of the address.  Also suppose that Continent is used as a type table for country and country is used as a type table for address.  In this case there would be a link from the External object element used for continent in the address to the internal object element used for continent in the continent object kind.  To indicate the Type Definition path, the External Object Element would use Type Definition Path as a type value which would have links to two Type Definitions 1. a link to the Type Definition that specifies that country is the type table for address and 2. a link to the Type Definition that specifies that continent is the type table for country.  So, if an address was created of type Mexico the name of the continent would be found as North America.
ELEM 2    2    1    342  2    4                   Object Element Usage Type--Paragraph #5
ELEM 2    2    1    344  2    5                   The Data Element Object Kind is used to define attributes that can be applied to Object Elements and serves as one of the type tables for Object Element. The Data Element contains a description and a length.  Data Element uses Data Type as a type table.  Object Elements that have the same length and similar purpose can use the same Data Element as a type value.  Data Elements of type Calculated String use a Function as a Type Value.  The Function is used to determine the value of Object Elements that use the Data Element as a type value.  The Function can determine the value using object values in the server database or it can also be linked to one or more Parameter Value Groups.  The Parameter Value groups are used to determine which parameters should be passed to the function to arrive at the Calculated string. This is done by checking parameter values included in a message being processed.  Parameter values that have the same Parameter Value Groups as the ones linked to from the Data Element can be passed to the Function used to arrive at the Object Element value.  The Parameter Values are then passed to the Function if the Function uses Parameters with the same ZTIC and Code.
ELEM 2    2    1    344  2    4                   Data Element--Paragraph #1
ELEM 2    2    1    467  2    4                   Data Element--Paragraph #2
ELEM 2    2    1    467  2    5                   Data Elements can also be used for reporting.  For example each Object Kind has a separate Object Element to hold the description of each Object Kind.  However each description Object Element refers to the same Data Element.  If a report lists all of the objects in a namespace the report could list values from all the Object Elements that use the Data Element used by descriptions
ELEM 2    2    1    345  2    5                   The Data Type serves as a type table for the Data Element table.  Its values include Numeric, Character, Boolean, Timestamp and Calculated String.  It allows the Data Element to specify which basic data type to use for the Data Element and thus which validations to perform.  The Data Type uses Function Group as a type value to specify the validation routine to be used for Data Elements that use that Data Type.  The validation i.e. for numerics, it would specify that the numeric details table would give the number of decimals etc.  The timestamp data type uses a Function that specifies timestamp validation.  The result of the Function execution is that if an insert is attempted that violates the validation, the server will return an error with an appropriate message.
ELEM 2    2    1    345  2    4                   Data Type--Paragraph #1
ELEM 2    2    1    346  2    5                   Data Elements can be configured to provide validation for Object Elements that use them.  A Data Element with a Data Type value of Character can use Object Set as a type value using Type Definition Code 48.  The Data Element with a Data Type value of Character can also use Object Element as a type value using Type Definition Code 49.  Type Definition 48 and 49 are used together to find the Object and Object Element containing valid character values for an Object Element using the Data Element being configured.  For example an Object Set name boolean could be used as a type value with members representing Generic Object Elements with valid character values including the values + for true, - for false and ? for initial or not determined value in the Object Element for Generic Object Element value.  Any Object Element using this Data Element would be limited to the values +, - or ?.
ELEM 2    2    1    346  2    4                   Valid Character Values--Paragraph #1
ELEM 2    2    1    347  2    5                   The Numeric Data Type Details, Object Kind Code 66, has the detailed specifications for the numeric fixed length data type.  It serves as a type table for Data Elements that use a Data Type of type Numeric.  It includes elements for minimum value, maximum value, smallest increment (step value) and start value.  The smallest increment is used to indicate the level of precision that the Data Element will permit.  As an example of how these are used, if the minimum value is 0, then negative values are not allowed.  If the start value is 0, the minimum in 0 and the smallest increment is 2 it only allows positive even integers and 0.  If the start value is 1 and the smallest increment is 2 it allows, odd numbers.  To determine if a numeric value is valid, first a check is done to make sure it is larger or equal to the minimum value and smaller or equal to the maximum value.  Then the start value is subtracted from the value to be validated and this result is divided by the by the smallest increment.  If the result is an integer, then the number passes the validation test.
ELEM 2    2    1    347  2    4                   Numeric Data Type Details--Paragraph #1
ELEM 2    2    1    348  2    5                   The Data Type table serves as the type table for the Numeric Data Type Details table.  To find the Function used to enforce the validation of numerics, the server must look at the related entry in the data type table because the Function is linked at the data type level.  The specific min, max and precision of a numeric type details entry would be passed as parameters to the Function.  For validation, if the number being validated is divided by the increment value it should result in an integer.
ELEM 2    2    1    348  2    4                   Numeric Data Type Details--Paragraph #2
ELEM 2    2    1    349  2    5                   Using of Extended Keys begins with configuring an Extended Key Definition, with Object Kind Code 33, or using an Extended Key Definition from the base standard such as language.  The Extended Key Definition uses Object Kind as a type table to indicate the valid keys for the Extended Key Definition.  For Example, the Extended Key Definition for language uses Object Kind Language, Object Kind Code 18 as a type table.  This means that the Extended Key Definition for language will use keys from the language table as possible key values.  The Extended Key Definition is invoked when a Data Element uses the Extended Key Definition as a type value.  For example, if one wants an Object Element to be language dependent, the Data Element used by that Object Element must specify the Language Extended Key Definition as a type value.
ELEM 2    2    1    349  2    4                   Extended Key Definition--Paragraph #2
ELEM 2    2    1    468  2    4                   Extended Key Definition--Paragraph #1
ELEM 2    2    1    468  2    5                   Extended Key Definitions are used to configure Object Elements that are accessed using key values beyond the Object Code ZTIC and Object Code. For example language (human) has an Extended Key Definition as part of the Base Specification. The base template for Extended Key Definition for language uses a Type Definition where Language is specified as the Type Table and the Set of all languages are allowed values. Fiscal period is an other example of a possible Extended Key.  An Object Element configured to use language or fiscal period as an Extended Key could only be accessed if the appropriate key was specified in the message.
ELEM 2    2    1    469  2    4                   Extended Key Definition--Paragraph #3
ELEM 2    2    1    469  2    5                   To populate an Object Element using an extended key, its necessary to specify the relevant keys in the message built by the client.  This is done in the header section of the message in the elements under Message Element 231.  Message Elements are explained later and are shown in Appendix 6.  Each key must specify the ZTIC and Code of the Extended Key Definition (in Message Elements 2311 and 2312) and the ZTIC and Code Extended Key value (in Message Elements 2313 and 2314).  In the case of an Extended Key for language, the the ZTIC for Extended Key Definition would be the Code associated with the base specification.  The Code would be 2 which is the Code for the Language Extended Key Definition.  The Extended Key value ZTIC would be the code associated with ISO units and the Code would be the correct value for the language being used, for example English, Spanish etc.
ELEM 2    2    1    470  2    4                   Extended Key Definition--Paragraph #4
ELEM 2    2    1    470  2    5                   When Object Element data is passed in a message for Object Elements that use extended keys, either to maintain an object or to query object data, the same Message Elements are used as are used for Object Elements that do not use extended keys.  That is Message Element 3044 to maintain an object and Message Element 4144 for a query response.  The difference comes when the Object Element values are stored in the database.  In this case, Table Elements 9 through 12 are used to store and retrieve the, Extended Key Definition ZTIC, Extended Key Definition Code, Extended Key Value ZTIC and Extended Key Value Code.  In this way, data that is stored with a certain extended key, for example language code, will only be retrieved when that extended key is provided in the Header of the message used to retrieve that data.
ELEM 2    2    1    471  2    4                   Extended Key Definition--Paragraph #5
ELEM 2    2    1    471  2    5                   There may be cases where it is useful to have an Object Element that depends on more than one Extended Key.  An example of this could be an Object Element that depends on both language and version.  Or perhaps the description for a financial application that depends on both language and fiscal period.  In this case the Object Element Definition still uses Extended Key Definition as a type value. The Extended Key Definition of type Composite must use an Object Kind of Type Composite Key as a type value.  This Object Kind must have a template that allows two or more type values so that an object of this kind could have a type value for a language and also a type value for version.  If a message is being processed to store Object Element data for an Object Element that is configured to use this composite Extended Key, the server creates a new object of the kind that will hold the composite keys.  It adds type values to the new object to specify, for example a certain language and a certain version and puts the new object ZTIC and code in Table ELements 11 and 12.  When data is retrieved, the server looks at the configuration of the Object Element being retrieved, finds that it uses a composite key and the related objects that hold the keys.  It checks if any of those objects have type values that match the extended keys provided in the query message.  If there is a match, then it now has the composite key value to retrieve the data.  Note that the composite key values are internal to a server and are not shared in any query response.  Two servers could have different composite keys to represent the same combination of type values.
ELEM 2    2    1    357  2    5                   The sequence number, stored in Table Element 27, will usually have a value of 0000.  If there is a situation where there already exists a record with the same Kind, Kind ZTI Code, Code, Code ZTI Code, and timestamp--effective and it is necessary to make the new record unique in the database, the sequence number would be incremented by 1.  The next record would be 0001, then 0002 etc.  Because the timestamp may represent fractions of a second, this will usually be enough to make the new record unique.  For this reason it is not likely that the sequence number will need to be incremented.
ELEM 2    2    1    357  2    4                   Timestamp Implementation--Paragraph #7
ELEM 2    2    1    352  2    5                   The effective timestamp is included in the key of database tables. Including negative numbers and decimals may be problematic.  The implementors can choose to modify the timestamp before inserting records into the database.  For example, if precision to milliseconds is permitted, the server could multiply Julian date in seconds   timestamp value by 1,000 to remove the decimal positions.  To avoid the use of negative numbers and to provide a fixed length timestamp, a large value I.e. 500,000,000,000,000,000 (5 x 10 17) could added to this number.
ELEM 2    2    1    352  2    4                   Timestamp Implementation--Paragraph #2
ELEM 2    2    1    353  2    5                   Timestamps can generally be compared by subtracting one from another.   However, when including time periods after leap seconds were introduced, the result would need to be adjusted to account for this when converting to conventional date/time representations.  Leap Seconds are maintained in a Leap Second table that is not included with the Base Specification.  The Leap Second object includes an effective timestamp indicating when the leap second should to added or subtracted to aid in timestamp calculation.
ELEM 2    2    1    353  2    4                   Timestamp Implementation--Paragraph #3
ELEM 2    2    1    354  2    5                   Under normal operations records in the database are not changed or deleted.  If the value for an object is changed, a new record is inserted with the new values, with a new timestamp to indicate when the record was inserted.  The old records would be retained.  By keeping the old records, it is possible to provide a change history if requested by the client.  The records are created under the code ZTI Code that is local to the data environment.  The timestamp--effective would usually be the time stamp (as defined above) of the local server at the time the record is inserted.  If the record was originally created on another server, the time stamp would usually be the timestamp time on that other server (as defined above) when the record was inserted on that other server.  If records are imported at various times from another server, using the timestamp from the other server as the effective time will cause the records to retain their proper order of creation when they are imported.
ELEM 2    2    1    354  2    4                   Timestamp Implementation--Paragraph #4
ELEM 2    2    1    355  2    5                   When a client makes a request to the server, it can specify which calendar should be used, what format the date should appear in which time zone to send the result in.
ELEM 2    2    1    355  2    4                   Timestamp Implementation--Paragraph #5
ELEM 2    2    1    356  2    4                   Timestamp Implementation--Paragraph #6
ELEM 2    2    1    356  2    5                   There are opportunities for the client to depart from the convention of using the time the records are inserted as the effective time.  Suppose the records are for prices that are not yet effective.  By inserting the records with a future effective date/time, the new prices will not take effect until that time arrives.  The server should reject effective timestamps that are in the past, unless they were created on an external system.  Current timestamps are assigned by the server, not the client.
ELEM 2    2    1    358  2    5                   Another situation that would require use of sequence number other than 0000 relates to effective timestamps that are in the future.  Suppose objects are added containing prices that are effective in the future.  At a later time, it is decided to change the price, but the effective time remains the same.  In this case, the sequence number could be incremented from 0000 to 0001.  The price with the 0001 sequence number would take precedence over the price with the 0000 sequence number.  Also, to make a record that will not become active (through the passage of time), add a record with the same key as an active record, but increment the sequence number and give the new record an inactive status.
ELEM 2    2    1    358  2    4                   Timestamp Implementation--Paragraph #8
ELEM 2    2    1    359  2    5                   The leap second table is used declare leap seconds to be used in the calculation of timestamps.  All official leap seconds are stored with their appropriate effective time.
ELEM 2    2    1    359  2    4                   Timestamp Implementation--Paragraph #9
ELEM 2    2    1    360  2    5                   The timestamp of creation is controlled by the server that is inserting the record.  It always contains the  timestamp of the record is inserted into the database, in converted from universal time without regard to where the record originated from.  The format of this timestamp is the same as the timestamp--effective.  This is not part of the database primary key.
ELEM 2    2    1    360  2    4                   Timestamp Implementation--Paragraph #10
ELEM 2    2    1    351  2    5                   The effective timestamp element is used to indicate the time when a record becomes effective.  The basis for timestamps is the Modified Julian Day which treats November 17, 1858, Midnight UTC, on the Gregorian calendar as the reference point.  This is assigned a timestamp value of 0.  The timestamp indicates the number of seconds or decimal fractions of a second elapsed since that reference point.  A negative number indicates the number of seconds or decimal fractions of a second before that point.  The base specification does not specify the number of decimal places that are permitted.  This is included in the General settings specification and could vary by implementation.
ELEM 2    2    1    351  2    4                   Timestamp Implementation--Paragraph #1
ELEM 2    2    1    377  2    4                   Protection Code--Heading
ELEM 2    2    1    377  2    5                   Protection Code
TYPE 2    2    1    377  2    2    2    1              
LINK 2    2    1    377  2    2    2    2    1    379                           5179248000.000           
ELEM 2    2    1    376  2    5                   Protection Type
ELEM 2    2    1    376  2    4                   Protection Type--Heading
TYPE 2    2    1    376  2    2    2    1              
LINK 2    2    1    376  2    2    2    2    1    378                           5179248000.000           
ELEM 2    2    1    374  2    4                   Protection Profile Type--Heading
ELEM 2    2    1    374  2    5                   Protection Profile Type
TYPE 2    2    1    374  2    2    2    1              
LINK 2    2    1    374  2    2    2    2    1    375                           5179248000.000           
ELEM 2    2    1    372  2    4                   Protection Profile--Heading
ELEM 2    2    1    372  2    5                   Protection Profile
TYPE 2    2    1    372  2    2    2    1              
LINK 2    2    1    372  2    2    2    2    1    373                           5179248000.000           
ELEM 2    2    1    370  2    4                   Data Protection Introduction--Heading
ELEM 2    2    1    370  2    5                   Introduction
TYPE 2    2    1    370  2    2    2    1              
LINK 2    2    1    370  2    2    2    2    1    371                           5179248000.000           
ELEM 2    2    1    368  2    5                   Note:  The base specification does not dictate the length of the code field.  An implementer could choose to use a short code length even replacing the code values for the standard entries with corresponding values from another coding scheme.  For example it could be a code scheme with a large character set.  The length of the code can have a large impact on database size.  This is because the code length is also becomes the length for the ZTI Code fields.  Of course, if the implementer chooses a very small maximum code length, it will not be able to interoperate with other systems that are sending objects with a longer code length.  To maintain interoperability, separate specifications (that are yet to be developed) that are targeted to particular usages can include a maximum code length.
ELEM 2    2    1    368  2    4                   Code Assignment Paragraph #7
ELEM 2    2    1    367  2    5                   Note: if it is desired to begin with pure numerics then use pure alpha, then specify numeric preferred and in the text file for code sequences specify the codes ABCDEFGHIJKLMNOPQRSTUVWXYZ.
ELEM 2    2    1    367  2    4                   Code Assignment Paragraph #6
ELEM 2    2    1    366  2    5                   Note: if codes with leading zeros are desired, the next code element should be initialized with leading zeroes, for example 0001 with a maximum length of 4.   If pure numeric codes are desired, the maximum code should be set to a numeric value (i.e. all 9s).  If the maximum value is longer than the maximum length, it will have no effect.  The maximum length will take precedence.
ELEM 2    2    1    366  2    4                   Code Assignment Paragraph #5
ELEM 2    2    1    365  2    5                   The codes assigned are only relevant for objects created locally (under the local ZTI) when the codes are assigned by the server.  Objects from foreign ZTIs would already have codes that were assigned on the foreign system and would be retained when imported.  Codes can also be assigned by the client if this is allowed for objects of a given kind and it is specified in the request message.  Code from external sources must also follow the rule that they are left-justified (no leading space), have no embedded spaces and cannot contain only zeros or only a ?.
ELEM 2    2    1    365  2    4                   Code Assignment Paragraph #4
ELEM 2    2    1    362  2    5                   When new objects are created using the namespace that is local to ZT Instance where they are being created, it will typically be necessary for the ZT Server to handle generation of new codes to identify the objects. To achieve this, there is some  configuration to be performed.  The Object Kind refers to an object called Code Range (Object Kind Code 21) as a Type Value.  In addition the Code Range must refer to an Object Kind called Code Scheme (Object Kind Code 22) as a Type Value. Code Range table includes elements called Next Code, Numeric Preferred, Minimum Code Value, Maximum Code Value and Maximum Code Length.  When an entry is added to the Object Kind table, the Next Code field for its Code Range must be initialized with a value that contains at least one character and cannot be all zeros and spaces.  It must be left justified (no leading spaces) and contain no embedded spaces.  It also cannot be longer than the Maximum Code Length specified. The Next Code is used to store the next code value to be allocated if an object an Object Kind using the Code Range is created.  After a code is allocated, the code is incremented and stored in the Next Code element.
ELEM 2    2    1    362  2    4                   Code Assignment--Paragraph #1
ELEM 2    2    1    363  2    4                   Code Assignment--Paragraph #2
ELEM 2    2    1    363  2    5                   The Code Scheme can be linked to a Function that specifies how the code is incremented.  The default Function for incrementing is as follows:  If the next code element in the Code Range contains a pure numeric value and the numeric preferred element is set to true, the next code is found by adding 1 to that numeric value.   The pure numeric must include characters from the set 0,1,2,3,4,5,6,7,8 and 9 (with no decimal point no plus sign and no minus sign).  Leading zeros, if present, are retained (0003 is incremented to 0004). This continues until the maximum value is reached or until the code is all 9s and its length equals the Code maximum length.
ELEM 2    2    1    364  2    5                   If the numeric preferred is not set to true or if all numeric values have been exhausted, the following Function applies by default.  There is a mandatory link from the relevant Code Scheme to a Resource that refers to a text file containing a string of non-repeating characters with no embedded spaces for example 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$@.  When a code needs to be incremented the server takes the following steps: Evaluate the right-most (non-space) position in the next code element and search the text string for this value.  If the value is not found change the right-most position of the next code element to the first value in the text string.  If the value is found in the text string, change the right-most position of the next code element to the next value in the text string after the one found.  If the value found in the text string is the last value in the text string, change the right-most value in the next code element to the first character in the text string and then evaluate the character one position to the left in the next code element and change it using the same rules as the right-most position.  If there is no position to the left in the next code element, create it and give it a value from the first character in the text string.  Exception:  if the first element in the text string is 0 then use the next position in the text string.  Continue this process until the next code would exceed the length specified in the code length element.  At this point an error is raised: Next code is longer than allowed length.  If a new code is requested and the next code element already equals the maximum value then an error is raised
ELEM 2    2    1    364  2    4                   Code Assignment--Paragraph #3
ELEM 2    2    1    315  2    5                   As an object is maintained through time, the ZT Server retains the various versions of the object attributes.  The standard key includes a time stamp, in Table Element 26,  which is used to maintain the multiple versions.  To illustrate usage of the timestamp, assume an example sales order application.  Typically a sales order application would use master data, for example, the customer master and item master.  These are used to build the transactional data, the sales order.  The example assumes a simplified set of master data and a sales order shown below.
ELEM 2    2    1    315  2    4                   Rationale and Approach to Versioning--Paragraph #1
LINK 2    2    1    315  2    4    6    1    1    1002                          5179248000.000           
ELEM 2    2    1    435  2    5                   The sales order shown includes only one line-item.  The master data objects are referred to in the sales order using their key, 1 for customer (ABC Co.) and 10 for item master (Bananas).
ELEM 2    2    1    435  2    4                   Rationale and Approach to Versioning--Paragraph #2
ELEM 2    2    1    436  2    5                   The difficulty arises when there is a change to the master data.  Suppose the customer changed their name from ABC Co. to DEF Co. and this is changed in the customer master.  If someone displays the sales order, it will show that the Sale was from DEF Co. even though it was originally created for ABC Co.  This may be okay in some cases and in others may cause confusion.
ELEM 2    2    1    436  2    4                   Rationale and Approach to Versioning--Paragraph #3
ELEM 2    2    1    437  2    5                   One way to remedy this problem is to copy the customer name into the sales order.  Since the item master has a similar problem, we could also copy in the item description as below.
ELEM 2    2    1    437  2    4                   Rationale and Approach to Versioning--Paragraph #4
LINK 2    2    1    437  2    4    6    1    1    1003                          5179248000.000           
ELEM 2    2    1    438  2    5                   Of course, There is more in the customer master than the customer name.  Any of these elements such as customer telephone number and customer address and customer contact person could change over time.  To have a true picture of what these values were at the time the order was created, it would be necessary to copy all of the master data into the sales order.  To ensure a consistent truth throughout the system it would also be necessary to protect that master data values in the sales orders from changes.  Generally applications take a hybrid approach, copying in some elements from the master data into the transactional data and accepting a level of data inconsistency across the system.
ELEM 2    2    1    438  2    4                   Rationale and Approach to Versioning--Paragraph #5
ELEM 2    2    1    439  2    5                   The ZT server uses a key with a timestamp to record when a value became effective. Links are created from objects to other objects so they can relate to the correct version of the object linked to at the time the link was created.  For example, when the customer name changes, this is reflected with a second record with the new name and a timestamp that indicates when the change is effective.
ELEM 2    2    1    439  2    4                   Rationale and Approach to Versioning--Paragraph #6
LINK 2    2    1    439  2    4    6    1    1    1004                          5179248000.000           
ELEM 2    2    1    440  2    5                   By using timestamps with links and Type Values, the ZT Server can access the version of the master data that existed at the time the sales order was created, even if the master data subsequently changed.  This is a simplified example.  A Sales Order design would more likely contain a header linked to line items with other objects related by some combination of Links and Type Values.
ELEM 2    2    1    440  2    4                   Rationale and Approach to Versioning--Paragraph #7
ELEM 2    2    1    448  2    4                   Server Definition--Paragraph #1
ELEM 2    2    1    448  2    5                   A ZT Server is a system that can process messages from a ZT Client.  The Server is responsible for handling updates to the back-end database.  One aspect of this is maintaining of Sever DB--ZT Instance IDs.  Server DB--ZT Instance IDs are used to create a separate data environment designated for maintaining data for a specific ZT Instance.  Server DB--ZT Instances are populated in the Table Element identified with Code 32.  This can be populated as an element within a table or it can be embedded in the name of the table itself.  The Server DB--ZT Instance ID is associated with a unique namespace that identifies a ZT Instance to the outside world.  The relationship between the Server DB--ZT Instance ID and its namespace should be maintained by the server in a configuration file or configuration table that is accessed when the ZT Server is started.  The relationship between the Server DB--ZT Instance ID and its namespace should not be changed after it is established, especially if data from that ZT Instance has been distributed to other systems.  A message from a Client identifies the target ZT Instance in Message Element 223 which has the Receiver ZT Instance Code.  The namespace for the Receiver ZT Instance code is found by looking for the namespace in Message Element 2101 that is associated with the ZT Instance code in  Message Element 2100.  Based on the namespace of the target (receiver) instance, the server can determine the Server DB--ZT Instance ID and use it to populate any data being updated.
ELEM 2    2    1    298  2    5                   Extended Key Definitions are used to configure Object Elements that are accessed using key values beyond the Object Code ZTIC and Object Code.   For example language (human) has an Extended Key Definition as part of the base specification.  The base template for Extended Key Definition for language uses a Type Definition where Language is specified as the type table and the Set of all languages are allowed values.  Fiscal period is an other example of a possible  extended key.
ELEM 2    2    1    298  2    4                   Extended Key Definition--Paragraph #1
ELEM 2    2    1    445  2    5                   This illustrates how objects from different sources can maintain their uniqueness in the same table.  The actual namespaces could be based on a URL to guarantee uniqueness across ZT instances.   The ZT Instance table provides cross-reference between the ZT Instance  code and the actual namespace.   Records in other tables in the database (other than the ZT Instance table)  use the ZT Instance Code (ZTIC) instead of the actual namespace.  When a message is sent between client and server it includes a cross reference between the namespace and the Code used to represent it in the message.  When the server receives a message requesting an insert containing a namespace, it checks the ZT Instance table to see if the namespace exists.  If it does not exist, the new namespace can be added along with a cross-reference to its namespace.  The server finds the ZT Instance code that represents the namespace and uses that to store the record.  Two ZT servers could use the same code internally to represent different namespace.  This is not a problem because any time the data is converted to a message to be used externally, the namespace in its appropriate long form is declared in the message.
ELEM 2    2    1    445  2    4                   ZT Instances--Paragraph #10
ELEM 2    2    1    317  2    4                   ZT Instances--Paragraph #1
ELEM 2    2    1    317  2    5                   The ZT Instance represents a distinct occurrence of an environment for storing data in a ZT Server.  A ZT Client specifies the target ZT Instance when sending a message to the Server.  A user, logging in through a Client, would typically interact with only one ZT Instance per login session.   The application data for the two ZT Instances would be completely separated.
ELEM 2    2    1    318  2    5                   The ZT Instance Code (ZTIC) elements are used to identify a ZT Instance and indicate the source of an object within a ZT Instance.  They are included so that objects from different sources can have the same Kind Code or Object Code value and still have unique identifiers. Each ZT Instance represents its own environment for assigning ZT Instance codes.  Also each message will contain its own environment for assigning codes to ZT instances.  The ZT Instance Code used to represent the local instance within a ZT Instance can have any value but by convention will use the value 1 (the first ZT instance to be declared within a new ZT instance).  ZT instance code 2 by convention represents objects of the Base Specification.  Other ZT Instance Codes can have any other value.  Within each environment the ZT instance Codes will be associated with a namespace that must NOT be changed after it is assigned and used to send data to other systems.
ELEM 2    2    1    318  2    4                   ZT Instances--Paragraph #2
ELEM 2    2    1    319  2    4                   DS Instances--Paragraph #3
ELEM 2    2    1    319  2    5                   DS instance codes are unique only within the context of the DS instance or within a message.  Namespaces must be universally unique to avoid naming conflicts when data is shared among DS instances.
ELEM 2    2    1    320  2    5                   ZT Instance Codes (ZTIC) are unique only within the context of the ZT Instance or within a message.  Namespaces must be universally unique to avoid naming conflicts when data is shared among ZT instances.  When a message is processed, the server must take care of converting from the ZT Instance Codes within the message to the ZT Instance Codes used in the target server by using the namespaces associated with the ZT Instance Codes.  A namespace is designed to be a set of characters that is unique from any other namespace.  To ensure uniqueness it is generally recommended to include an Internet domain name in the namespace.  An example namespace could be my_email_address@a_domain_name.com/my_test_system1.
ELEM 2    2    1    320  2    4                   ZT Instances--Paragraph #4
ELEM 2    2    1    321  2    4                   DS Instance--Paragraph #5
ELEM 2    2    1    321  2    5                   When two ZT Instances share the same Server database tables, they are differentiated using the Server DB--ZT Instance ID, Table Element 32.  Each Server DB--ZT Instance ID is associated with exactly one namespace.  The Server DB--ZT Instance ID does not need to be universally unique, only unique within a Server database.  For example, two servers could use the Server DB--ZT Instance ID called TEST, but they would be differentiated by using unique namespaces, for example dev1.com/test_env and dev2.com/testing_place.  The calling client only needs to specify the namespace of the target ZT Instance in the message and there is no particular need for the client to be aware of the Server DB--Instance ID.  The message and message response only refers to namespaces and related ZT Instance Codes.  The ZT Instance Codes along with the namespaces make it possible to distribute data from one ZT Instance to another without naming collisions.  The following example illustrates the usage of ZT Instance Codes.
ELEM 2    2    1    442  2    4                   ZT Instance--Paragraph #7
ELEM 2    2    1    442  2    5                   A second developer, developer #2, imports the objects from developer #1 and adds some Food Types, for cat and dog foods.  Notice that the ZT Instance code (ZTIC) for the objects imported from developer #1 is different than it was on the first server (101 instead of 1), but the code still represents the same namespace (dev1.com).  The new Food Types are created under the local ZT Instance labeled 1.  Developer #2 adds foods for humans, cats and dogs. He also translates the object kind to Spanish.  The Code and Code ZTIC for the Spanish translation in the Kind table are the same as the English name.  They both have the Code ZTIC 101 to represent the namespace of the original developer (dev1.com).  The Modifier ZT Instance Code indicates which ZTIC a change to an object originated from.  The MZTIC (modifier ZTIC) is 1 to represent dev2.com because developer #2 modified an object that was created by developer #1.
LINK 2    2    1    442  2    4    6    1    1    1006                          5179248000.000           
ELEM 2    2    1    443  2    4                   DS Instances--Paragraph #8
ELEM 2    2    1    443  2    5                   Note:  The food table has duplicate codes in it, but these are differentiated by the ZT Instance Codes (ZTIC).  Also the Food Type T1 is used to represent human food (from developer #1) and cat food (from developer #2).  These are differentiated by the Type Value ZTIC, 101 for developer #1 and 1 for developer #2.
ELEM 2    2    1    444  2    4                   DS Instances--Paragraph #9
ELEM 2    2    1    444  2    5                   A third developer, developer #3, receives the objects from developer #2 and imports them into a 3rd ZT Instance and adds a Food Type for bird food, the foods Bird Seed, Bird Feed, Rice, Tofu and Beans under the ZT Instance Code 1.  Each of these foods is given its code sequentially starting from 1.  The table entries for developer #3 would appear as follows.
LINK 2    2    1    444  2    4    6    1    1    1007                          5179248000.000           
ELEM 2    2    1    446  2    4                   ZT Instances--Paragraph #12
ELEM 2    2    1    446  2    5                   Note:  There is significant reuse of constructs within the specification.  This tends to blur the distinctions between system definition, application development, configuration, master data and transactional data.  The use of separate ZT Instances can help clarify this.  For example, development and configuration could occur in a separate ZT Instances (ZTI).  When development and configuration is completed it can be transferred to another ZTI for testing and/or transactional postings.  The transferred objects retain the namespace of the source ZTI where they were created.  This makes them identifiable if they need to be removed.
ELEM 2    2    1    454  2    4                   ZT Instances--Paragraph #11
ELEM 2    2    1    454  2    5                   The pattern described here could be extended to enrich the application further.  For example, a fourth developer could decide to build an application for handling recipes that includes the possibility of creating links to the foods depicted here as ingredients.  It would also need to include quantities, units of measure and cooking instructions.  A fifth developer could then use the recipe application to build a recipe book that allows the possibility for the recipe book to create links to recipes.  It was mentioned that developers can distribute their work to other developers.  To achieve this, is is necessary to have a client application that queries a ZT Instance and maps the Response to the Request of a new message.  The new message can then be imported by others.
ELEM 2    2    1    441  2    4                   ZT Instance--Paragraph #6
ELEM 2    2    1    441  2    5                   This example shows how data from several ZT Instances can be used to enrich an application.  For this example, suppose a developer wants to create a ZT Object Kind for storing food data with some useful attributes such as name and calories per kilogram. The ZT Instance that the developer is working in is associated with namespace dev1.com and ZT instance code 1 (the local instance).  The developer creates an Object Kind for food and creates the foods Bread and Lettuce.  The developer also creates an Object Kind for Food Type and adds an entry for Human Food.  Table entries are shown below.  Some elements are omitted to simplify the example.  Also, language dependent and language independent rows are presented as a composite in the same table row.  In actual practice they could be stored in separate tables.  In the composite views, language dependent entries that appear for multiple languages have repeated rows.
LINK 2    2    1    441  2    4    6    1    1    1005                          5179248000.000           
ELEM 2    2    1    311  2    5                   Conditional values can serve as the type table for Link Types and Link Target Types.  If the function associated with the conditional value returns a false, all of the links associated with the Link Type or the Link Target Type are suppressed.
ELEM 2    2    1    311  2    4                   Software Modules--Paragraph #9
ELEM 2    2    1    303  2    4                   Function Group--Paragraph #1
ELEM 2    2    1    303  2    5                   Function Groups are used to organize a set of functionality that can be called in a generic manner.  Function Groups can be linked to one or more Functions that are to be executed and one or more System Messages that provide the boilerplate text to be added as log messages.  The Function Group calls each Function and possibly replaces portions of boilerplate system messages with variable values.  One important use for Function Groups is for validations.  The Function Group can be used to analyze an incoming message, do a validation check, add appropriate log messages and set the status of message, for example to indicate that the validation failed.
ELEM 2    2    1    304  2    4                   Software Modules--Paragraph #2
ELEM 2    2    1    304  2    5                   The Function Group (Object Kind Code 52) is linked to System Messages (Object Kind Code 24) using Link Type Code 31 and Functions (Object Kind Code 36) using Link Type 32.  The function is linked to a set of parameters (using Link Type Code 8).    The Function Group handles populating parameters that will be used by the functions.  The Function Group includes an Object Element that can be populated with a start parameter.  This can be used in a variety of ways including being used to determine the choreography of Functions to be called.  By default each function is called once based on the link value of the links from the Function Group to the Functions with the links with the high values being called first.
ELEM 2    2    1    306  2    4                   Software Modules--Paragraph #4
ELEM 2    2    1    306  2    5                   -
ELEM 2    2    1    305  2    5                   An example of how a Function Group can be used is the Function Group with code 2 in the validation namespace, outside of the base specification.  This is used to validate that that if an object is being maintained with links to existing objects that the objects being linked to actually exist in the database.  Function with Code 2, in the validation namespace was created to perform the validation.  System message with Code 2, in the validation namespace was added to provide a message that can be logged if the validation fails.
ELEM 2    2    1    305  2    4                   Software Modules--Paragraph #3
ELEM 2    2    1    307  2    4                   Software Modules--Paragraph #5
ELEM 2    2    1    307  2    5                   -
ELEM 2    2    1    308  2    5                   -
ELEM 2    2    1    308  2    4                   Software Modules--Paragraph #6
ELEM 2    2    1    309  2    5                   -
ELEM 2    2    1    309  2    4                   Software Modules--Paragraph #7
ELEM 2    2    1    310  2    5                   Note:  The Conditional Values are processed in order of precedence.  The first Conditional Value that evaluates as true would be utilized and the rest ignored. In the case of incest which causes a brother and a nephew to be the same person only the first Conditional Value that evaluates as true would be used.
ELEM 2    2    1    310  2    4                   Software Modules--Paragraph #8
ELEM 2    2    1    312  2    5                   -
ELEM 2    2    1    312  2    4                   Software Modules--Paragraph #10
ELEM 2    2    1    313  2    5                   A possible elaboration would be to permit the Conditional Values to be linked not only to an Object Element containing fixed values but also to a function that returns a value at runtime if the boolean expression for that Conditional Value is determined to be true.
ELEM 2    2    1    313  2    4                   Software Modules--Paragraph #11
ELEM 2    2    1    551  2    4                   Statistical Values Introduction
ELEM 2    2    1    551  2    5                   Statistical Values are used by the ZT Server to provide summarized object data to a ZT Client.  Suppose, for example, that the ZT Server contains a large number of financial postings and the user would like to query a summarized version of the postings, not retrieve all of the individual postings.  Suppose also, the requirement is to display the postings in a spreadsheet workbook.  The postings for a each year are to be displayed in separate spreadsheet tabs in the workbook.  Each spreadsheet needs to have twelve columns, one for each Gregorian month of the year and a row for each account.
ELEM 2    2    1    552  2    4                   Statistical Values--P2--Overview
ELEM 2    2    1    552  2    5                   Statistical Values can be implemented using a Statistical Values Object.  The Statistical Values Object refers to an Object Element that contains the data to be summarized and Dimensions used to determine how the data is to be summarized. In the example of summarized financial postings, the Statistical Values Object would refer to the Object Element containing the financial posting amount and to several dimensions used to accumulate the postings into appropriate buckets. The first Dimension could be for general ledger account, the second could be for month and a third Dimension for year. Each of the Dimensions would refer to another object called Type Definition Path. The Type Definition Path indicates which Type Definitions in the hierarchy of Type Definitions would be used to arrive at the object used for summarization. A financial posting could use general ledger account directly as a Type Value. In this case, the Type Definition Path would contain only one Type Definition, general ledger account for a financial posting. The Dimension for Month would use a Type Definition Path that refers to four Type Definitions, posting date (timezone dependent) for a financial posting, day (timezone independent) for a date, month and year for a day and month for a month a year. The third dimension would refer to a Type Definition Path that includes date for a financial posting, day for a date, month and year for a day and year for a month and year. For each financial posting in the specified set of financial postings, the ZT Server finds the value for account, month and year by traversing the type values for the posting through the Type Value hierarchies. Any postings that share the same general account, month and year would be accumulated into the same statistical bucket.
ELEM 2    2    1    553  2    4                   Statistical Values--P3--details1
ELEM 2    2    1    553  2    5                   The objects configured are all in the base namespace. The Object Kind for Statistical Values uses Code 58.  The Object Element that contains the data to be summarized is referred to as a Type Value of the Statistical Values Object using Type Definition with Code 37.  The Statistical Values Object refers to a Set of objects to be summarized using Type Definition with code 33. The Statistical Value Dimensions Object Kind use Code 59.  The Statistical Values Object can be linked to one or more Dimension using Link Type with Code 26.  Each Dimension refers to a Type Definition Path using Type Definition with code 34.  The Type Definition Paths are linked to the Type Definitions included in the Type Definition Path using Link Type with code 27.
ELEM 2    2    1    554  2    4                   Statistical Values--P4--Response
ELEM 2    2    1    554  2    5                   When a Statistical Values Object is included in the response to a Query, the server also calculates the summarized values and places them in the Query Response section of the message in Message Elements that are children of Message Element with code 4180.  Message Elements 41810 and 41811 contain the Statistical Values Object ZTIC and Statistical Values Object code.  Message Elements 41812 and 41813 contain the Statistic Type ZTIC and Code that was configured for the Statistical Values Object. Options include Code 1 for sum, Code 2 for count, Code 3 for average and Code 4 for standard deviation in the base namespace.  Message Elements 41814 and 41815 contain the ZTIC and Code of the Set that specifies the objects that contain the values to be summarized.  Message Elements 41816 and 41817 contain the ZTIC and Code of the Unit of Measure related to the values being summarized.  Message Elements 41820 and 41821 contain the ZTIC and Code of the Object Element that contains the numeric data to be summarized and Message Element 41822 contains the label of the Statistical Values Object. The details for Dimensions, Statistical Values and Groups appear under Message Element 4183, 4185 and 4187 respectively.
ELEM 2    2    1    555  2    4                   Statistical Values--P5--Dimension
ELEM 2    2    1    555  2    5                   The Dimensions relevant to a Statistical Values Object Response are included under Message Element 4183 and values for an individual Dimension are under Message Element 41830.  The ZTIC and Code for the Dimension are in Message Elements 41831 and 41832.  The Dimension label is in 41833.  Message Element 41834 has the index in related Type Definition Path to indicate the Type Definition used for summarization.  The Type Definition Path can be viewed as an array of Type Definitions with array indexes that begin with 0 and continue sequentially using positive integers.  Index 0 of the Type Definition Path refers to the Type Definition that is used immediately by the object being summarized.  For example for a financial posting, the account could be one of its type values.  This would make it a Type Definition with index 0 in the Type Definition Path.  In this case, the index in Message Element 41834 would be 0 for the Statistical Values Dimension used for account.  The Dimension for Month has a larger array of Type Definitions because Month is not directly and type value of financial posing.  To find the month in Type Definition Path is is necessary to navigate through the Type Definitions in the path.  For example, financial posting uses date as a type value (index 0).  Date uses day as a type value (index 1).  Day uses month and year as a type value (index 2) and month and year uses month as a type value (index 3).  In this case index in Message Element 41834 would be 3 to allow summarization at month level.  Message Element 41835 contains an ID used for grouping.  The client may also want the summarized data to be grouped.  For example it may be important to group all income accounts together and put all expense accounts in a different group.  This could be based on a type value for account such as account category.  The account category would indicate if the account is an income account or expense account etc.
ELEM 2    2    1    556  2    4                   Statistical Values--P6-Values
ELEM 2    2    1    556  2    5                   The actual values for the Statistical Values Object are listed under Message Element 4185.  Message Element 41851 holds Statistical Value ID and 41852 has the Statistical Value.  In this example the Statistical Value would be the sum of financial postings that are members of the Object Set configured for the Statistical Values Object for a particular account, month and year.  The details of the Type Values used to characterize the Statistical Value are listed under Message Element 4186.  This includes the ZTIC and Code for the Type Definition and the Type Values that the Statistical Value relates to.  For this example there would be three occurrences of Message Element 41860, Statistical Value Type Value, one for account, one for month and one for year.  Message Element 41865 through 41868 are used for grouping, sorting and labeling of the Statistical Value.
ELEM 2    2    1    557  2    4                   Statistical Values--P7--Grouping
ELEM 2    2    1    557  2    5                   Message Element 4187 and its children address the definition of groupings for Statistical Values.  The grouping ID in message element 41881 identifies a particular grouping and is referred to in message elements 41867, 41868 and 41869.  Message elements 41886 and 41887 are used to hold the ZTIC and Code of the type value used for grouping, in the financial postings example it could refer to an account category to indicate if the account is an income statement or an expense account.  Message Element 41885 holds the index in the Type Definition Path where the grouping occurs.  Statistical Values that share the same grouping ID can be grouped together when it is displayed by the client application.
ELEM 2    2    1    559  2    4                   Response Type-P3
ELEM 2    2    1    559  2    5                   The ZTIC and Code for Response Types specified in the request in Message Element 31051 and 31052 are referred to in the query response in Message Elements 41051 and 41052.  Message Element 31053 through 31056 in the request refer to a related object based on the Response Type.  For example, if the the Response Type is 6, for object set members for sets that are type values of queried objects then Message Elements 31053 through 31056 would refer to the Object Set. Message Element 41053 through 41056 in the response refer of the related object based on the Response Type.  The values in Message Elements 31051 through 31056 are used to determine if the response control parameters are invoked.  These message elements can contain the typical ZTIC and Code values to represent the response type and the related object.  They can also contain a * to indicate that it represents all values for ZTIC and Code to refer to a more generalized set of query response control parameters.
ELEM 2    2    1    570  2    4                   Response Type-P1
ELEM 2    2    1    570  2    5                   Response Types are used to control the content of the response returned by the server.  For example, when an Object Set is queried or an object that is linked to an Object Set is queried or an object that uses an Object Set as a Type Value is queried, by default the server returns the members of that set in the message response.  There may be cases where the set is too large to return in one response.  By setting Query Response Control Parameters, the client can control how many set members are returned.
ELEM 2    2    1    571  2    4                   Response Type-P2
ELEM 2    2    1    571  2    5                   The Query Response Control Parameters are under message element 3107.  The Response Type ZTIC and Code are in Message Elements 31071 and 31072. The base specification includes Response Type codes: 1 for standard, 2 for Template of a Linkable Object, 3 for permitted type values, 4 for permitted link-to values, 5 for object set members for sets that are linked to and 6 for object set members for sets that are type values of queried objects.
ELEM 2    2    1    572  2    4                   Response Type-P4
ELEM 2    2    1    572  2    5                   The response control parameters values are in Message Elements 31060 through 31065.  Message Element 31060 has the maximum number of objects returned.  Message Element 31061 has the maximum number of hierarchy levels returned.  Message Element 31062 has the offset from the beginning object.  For example if a set contains 1,000 members and the maximum number of set members to return is 100, if the offset was set to 300 then the server would return members 301 to 400.  Message Elements 31063 and 31064 hold the ZTIC and Code of a sort object to determine which order the objects would be returned in.  Message Element 31065 has the set member response mode.  Mode 1 indicates, return minimal data content for a set member, mode 2 indicates maximum data content.
ELEM 2    2    1    573  2    4                   Response Types-P5
ELEM 2    2    1    573  2    5                   It was mentioned that using * for ZTIC or Code allows for a generalized application of Query Response Control Parameters.  When evaluating a set of Query Response Control Parameters the server looks at the most generalized values first then looks at parameters that specify a more specific selection.  If a more specific selection the matches the scenario being process, then the more specific parameters are used to overwrite the generalized parameters.  If the specific selection does not match exactly the scenario being processed, it is ignored.  As an example, suppose a query selection contains an object that uses an Object Set as a Type Value.  This would match Response Type 6, for object set members for sets that are type values of queried objects.  If there was a specific Query Response Control Parameter for Response Type 6 and a related object referring to that specific set, then parameter values such as maximum number of members returned would be invoked, if there was not a match the parameters would be ignored. When multiple Query Response Control Parameters have * for key values, these are the rules for determining which parameters are more generalized.  The Message Elements that refer to the Response Type are more generalized than the Message Elements that refer to the related object.  Message Elements that refer to the Object Kind are more generalized than the Message Elements that refer to the specific object of that kind.  Finally, Message Elements that refer to the ZTIC are more generalized that message elements that refer to a Code.
ELEM 2    2    1    395  2    4                   Message Processing Introduction
ELEM 2    2    1    395  2    5                   The primary task of a ZT Server is to receive messages from a client, validate that the messages are properly formatted, interpret the messages, maintain or query object data and return appropriate responses.  This section describes the syntax of a standard message and the tasks performed by a ZT Server to process the message.
ELEM 5    2    1    2009 5    5                   Message Structure
ELEM 5    2    1    2009 5    4                   Message Structure
ELEM 2    2    1    425  2    4                   Message Definition--Response QueryResponseSet Section
ELEM 2    2    1    425  2    5                   Response QueryResponseSet
TYPE 2    2    1    425  2    2    2    1              
LINK 2    2    1    425  2    2    2    2    1    473                           5179248000.000      10000
ELEM 2    2    1    424  2    4                   Message Definition--ResponseSet Section
ELEM 2    2    1    424  2    5                   Response MaintainResponseSet
TYPE 2    2    1    424  2    2    2    1              
LINK 2    2    1    424  2    2    2    2    1    472                           5179248000.000      10000
ELEM 2    2    1    423  2    4                   Message Definition--Request QuerySet
ELEM 2    2    1    423  2    5                   Request QuerySet
TYPE 2    2    1    423  2    2    2    1              
LINK 2    2    1    423  2    2    2    2    1    431                           5179248000.000      9000 
LINK 2    2    1    423  2    2    2    2    1    432                           5179248000.000      8000 
LINK 2    2    1    423  2    2    2    2    1    433                           5179248000.000      10000
LINK 2    2    1    423  2    2    2    2    1    434                           5179248000.000      7000 
ELEM 2    2    1    422  2    5                   Request MaintainSet
ELEM 2    2    1    422  2    4                   Message Definition--Request Maintain Section
TYPE 2    2    1    422  2    2    2    1              
LINK 2    2    1    422  2    2    2    2    1    430                           5179248000.000      9000 
LINK 2    2    1    422  2    2    2    2    1    429                           5179248000.000      10000
ELEM 2    2    1    421  2    5                   Header
ELEM 2    2    1    421  2    4                   Message Definition--Header Section
TYPE 2    2    1    421  2    2    2    1              
LINK 2    2    1    421  2    2    2    2    1    427                           5179248000.000      9000 
LINK 2    2    1    421  2    2    2    2    1    426                           5179248000.000      10000
LINK 2    2    1    421  2    2    2    2    1    428                           5179248000.000      8000 
ELEM 2    2    1    397  2    5                   Introduction
ELEM 2    2    1    397  2    4                   Message Definition Introduction--Heading
TYPE 2    2    1    397  2    2    2    1              
LINK 2    2    1    397  2    2    2    2    1    398                           5179248000.000           
ELEM 2    2    1    403  2    5                   The structure of the communication form of the message is listed below.
ELEM 2    2    1    403  2    4                   Message Syntax--Paragraph #3
LINK 2    2    1    403  2    4    6    1    1    1010                          5179248000.000      10000
ELEM 2    2    1    402  2    5                   Messages could be communicated to a server using any protocols the server supports.  For example, the Message segments could be put into a JSON document and transferred via a Web Service call.  Message segments could be sent as a set of table rows containing message segments, assuming the server has access to that table.  They could also be contained in a xml document with a simple structure to contain the segment data.  Alternatively segments could be sent in a file with the segments separated by line feeds.
ELEM 2    2    1    402  2    4                   Message Syntax--Paragraph #2
ELEM 2    2    1    401  2    5                   The Message Definition described thus far relates to the hierarchy of message data for the request that would be populated by the client and processed by the server and the response to be populated by the server and interpreted by the client.  The structure of the message as it is communicated i.e. from client to server differs from this.  The message used for communication can be viewed as a series of segments.  Each segment is assigned a sequential integer beginning with serial number 1.  Each segment contains the serial number of its parent.  It also contains a reference to a Message Element ZTIC and Code which indicates the placement of the message data within the hierarchical structure of the Message Definition. The parent of the segment with serial number 1 is 0.  Segments are always added (appended) to the end of the message and always a child of a previously added segment.
ELEM 2    2    1    401  2    4                   Message Syntax--Paragraph #1
ELEM 2    2    1    488  2    5                   Note:  Segment with serial number 0 is a segment that can be added to pass instructions to the server related to, for example, the structure of the message.  The parameter segment takes the form of a string with segment serial number 0 followed by the parameters.  Each parameter begins with a [ character followed immediately by a character that will be used as a delimiter for the parameter values that follow.  For example for comma separated values it the parameter would begin with [, values.  These are followed by the parameter ZTIC, the parameter Code and the parameter value.  These are separated by the delimiter which is this case is the comma.  The parameters could include the namespace and code of the table to indicate the structure of the incoming message.  This can be used if there is a desire for a more compact message by using something other than the default structure for the communication message.  For example, Table Element 4 in the default structure is the ZTIC of the Message Element.  If only standard message elements are used, then this will always have the same value and could be omitted and the value for the ZTIC could be assumed.  Table Element 3 in the standard structure is to indicate the priority of child message segments.  If this is not important then this could also be omitted in the message.  This functionality applies only if it is supported by the server receiving the message.
ELEM 2    2    1    488  2    4                   Message Syntax--Paragraph #4
ELEM 2    2    1    405  2    5                   The following is a list of steps for Message Processing:
ELEM 2    2    1    405  2    4                   Message Processing Steps--List Intro
TYPE 2    2    1    405  2    2    2    3              
LINK 2    2    1    405  2    2    2    2    1    415                           5179248000.000      500  
LINK 2    2    1    405  2    2    2    2    1    414                           5179248000.000      1000 
LINK 2    2    1    405  2    2    2    2    1    413                           5179248000.000      2000 
LINK 2    2    1    405  2    2    2    2    1    412                           5179248000.000      3000 
LINK 2    2    1    405  2    2    2    2    1    411                           5179248000.000      4000 
LINK 2    2    1    405  2    2    2    2    1    410                           5179248000.000      5000 
LINK 2    2    1    405  2    2    2    2    1    409                           5179248000.000      6000 
LINK 2    2    1    405  2    2    2    2    1    408                           5179248000.000      7000 
LINK 2    2    1    405  2    2    2    2    1    407                           5179248000.000      8000 
LINK 2    2    1    405  2    2    2    2    1    406                           5179248000.000      9000 
ELEM 2    2    1    416  2    5                   Introduction
ELEM 2    2    1    416  2    4                   Message Processing Example--Introduction
TYPE 2    2    1    416  2    2    2    1              
LINK 2    2    1    416  2    2    2    2    1    474                           5179248000.000      10000
ELEM 2    2    1    417  2    5                   Create Address Message Example
ELEM 2    2    1    417  2    4                   Message Processing Example--Create Address
TYPE 2    2    1    417  2    2    2    1              
LINK 2    2    1    417  2    2    2    2    1    478                           5179248000.000      7000 
LINK 2    2    1    417  2    2    2    2    1    482                           5179248000.000      4000 
LINK 2    2    1    417  2    2    2    2    1    483                           5179248000.000      3000 
LINK 2    2    1    417  2    2    2    2    1    484                           5179248000.000      2000 
LINK 2    2    1    417  2    2    2    2    1    475                           5179248000.000      10000
LINK 2    2    1    417  2    2    2    2    1    476                           5179248000.000      9000 
LINK 2    2    1    417  2    2    2    2    1    477                           5179248000.000      8000 
LINK 2    2    1    417  2    2    2    2    1    479                           5179248000.000      6000 
LINK 2    2    1    417  2    2    2    2    1    481                           5179248000.000      5000 
LINK 2    2    1    417  2    2    2    2    1    495                           5179248000.000      1000 
LINK 2    2    1    417  2    2    2    2    1    496                           5179248000.000      900  
LINK 2    2    1    417  2    2    2    2    1    497                           5179248000.000      800  
LINK 2    2    1    417  2    2    2    2    1    498                           5179248000.000      700  
LINK 2    2    1    417  2    2    2    2    1    499                           5179248000.000      600  
LINK 2    2    1    417  2    2    2    2    1    500                           5179248000.000      500  
LINK 2    2    1    417  2    2    2    2    1    501                           5179248000.000      400  
ELEM 2    2    1    418  2    4                   Message Processing Example--Display DB update
ELEM 2    2    1    418  2    5                   Updated Database
TYPE 2    2    1    418  2    2    2    1              
LINK 2    2    1    418  2    2    2    2    1    489                           5179248000.000      10000
LINK 2    2    1    418  2    2    2    2    1    502                           5179248000.000      9000 
LINK 2    2    1    418  2    2    2    2    1    503                           5179248000.000      8000 
LINK 2    2    1    418  2    2    2    2    1    504                           5179248000.000      7000 
LINK 2    2    1    418  2    2    2    2    1    505                           5179248000.000      6000 
LINK 2    2    1    418  2    2    2    2    1    506                           5179248000.000      5000 
LINK 2    2    1    418  2    2    2    2    1    507                           5179248000.000      4000 
LINK 2    2    1    418  2    2    2    2    1    508                           5179248000.000      3000 
LINK 2    2    1    418  2    2    2    2    1    509                           5179248000.000      2000 
LINK 2    2    1    418  2    2    2    2    1    510                           5179248000.000      1000 
LINK 2    2    1    418  2    2    2    2    1    511                           5179248000.000      900  
LINK 2    2    1    418  2    2    2    2    1    512                           5179248000.000      800  
LINK 2    2    1    418  2    2    2    2    1    513                           5179248000.000      700  
LINK 2    2    1    418  2    2    2    2    1    514                           5179248000.000      600  
ELEM 2    2    1    419  2    4                   Message Processing Example--Address Query
ELEM 2    2    1    419  2    5                   Address Query
TYPE 2    2    1    419  2    2    2    1              
LINK 2    2    1    419  2    2    2    2    1    515                           5179248000.000      10000
LINK 2    2    1    419  2    2    2    2    1    516                           5179248000.000      9000 
LINK 2    2    1    419  2    2    2    2    1    517                           5179248000.000      8000 
LINK 2    2    1    419  2    2    2    2    1    518                           5179248000.000      7000 
LINK 2    2    1    419  2    2    2    2    1    519                           5179248000.000      6000 
LINK 2    2    1    419  2    2    2    2    1    520                           5179248000.000      5000 
LINK 2    2    1    419  2    2    2    2    1    521                           5179248000.000      5500 
LINK 2    2    1    419  2    2    2    2    1    522                           5179248000.000      4000 
LINK 2    2    1    419  2    2    2    2    1    523                           5179248000.000      3000 
ELEM 2    2    1    420  2    4                   Message Processing Example--Query Address Response
ELEM 2    2    1    420  2    5                   Query Address Response
TYPE 2    2    1    420  2    2    2    1              
LINK 2    2    1    420  2    2    2    2    1    536                           5179248000.000      700  
LINK 2    2    1    420  2    2    2    2    1    524                           5179248000.000      10000
LINK 2    2    1    420  2    2    2    2    1    525                           5179248000.000      9000 
LINK 2    2    1    420  2    2    2    2    1    526                           5179248000.000      8000 
LINK 2    2    1    420  2    2    2    2    1    527                           5179248000.000      7000 
LINK 2    2    1    420  2    2    2    2    1    528                           5179248000.000      6000 
LINK 2    2    1    420  2    2    2    2    1    529                           5179248000.000      5000 
LINK 2    2    1    420  2    2    2    2    1    530                           5179248000.000      4000 
LINK 2    2    1    420  2    2    2    2    1    531                           5179248000.000      3000 
LINK 2    2    1    420  2    2    2    2    1    532                           5179248000.000      2000 
LINK 2    2    1    420  2    2    2    2    1    533                           5179248000.000      1000 
LINK 2    2    1    420  2    2    2    2    1    534                           5179248000.000      900  
LINK 2    2    1    420  2    2    2    2    1    535                           5179248000.000      800  
LINK 2    2    1    420  2    2    2    2    1    537                           5179248000.000      600  
LINK 2    2    1    420  2    2    2    2    1    538                           5179248000.000      500  
LINK 2    2    1    420  2    2    2    2    1    539                           5179248000.000      400  
ELEM 5    1    1    1001 5    3                   2
ELEM 5    1    1    1001 5    2                   Base Object Kinds
ELEM 5    1    1    1001 5    1                   Object Kinds in base namespace
LINK 5    1    1    1001 5    2    5    3    1    3002                          5179248000.000      8000 
LINK 5    1    1    1001 5    1    5    2    1    2001                          5179248000.000           
LINK 5    1    1    1001 5    2    5    3    1    3001                          5179248000.000      9000 
LINK 5    1    1    1001 5    3    5    4    1    4001                          5179248000.000           
ELEM 2    2    1    480  2    5                   Listed below are the Object Kinds that are included in the Base Specification
ELEM 2    2    1    480  2    4                   Introduction of Base Object Kinds spreadsheet
LINK 2    2    1    480  2    3    5    1    1    1001                          5179248000.000           
ELEM 5    1    1    1020 5    1                   Type Definitions in Base Namespace
ELEM 5    1    1    1020 5    3                   2
ELEM 5    1    1    1020 5    2                   Type Definitions in Base Namespace
LINK 5    1    1    1020 5    2    5    3    1    3021                          5179248000.000      8000 
LINK 5    1    1    1020 5    1    5    2    1    2020                          5179248000.000           
LINK 5    1    1    1020 5    2    5    3    1    3020                          5179248000.000      9000 
LINK 5    1    1    1020 5    3    5    4    1    4020                          5179248000.000           
ELEM 2    2    1    541  2    5                   Listed below are Type Definitions in the base specification
ELEM 2    2    1    541  2    4                   Intro for Type Definition List
LINK 2    2    1    541  2    3    5    1    1    1020                          5179248000.000           
ELEM 5    1    1    1021 5    1                   Object Elements in Base Namespace
ELEM 5    1    1    1021 5    3                   2
ELEM 5    1    1    1021 5    2                   Object Elements  in Base Namespace
LINK 5    1    1    1021 5    2    5    3    1    3022                          5179248000.000      9000 
LINK 5    1    1    1021 5    2    5    3    1    3023                          5179248000.000      8000 
LINK 5    1    1    1021 5    1    5    2    1    2021                          5179248000.000           
LINK 5    1    1    1021 5    3    5    4    1    4021                          5179248000.000           
ELEM 2    2    1    540  2    5                   Listed below are the Object Elements in the base specification.
ELEM 2    2    1    540  2    4                   Intro for Object Element List
LINK 2    2    1    540  2    3    5    1    1    1021                          5179248000.000           
ELEM 5    1    1    1023 5    3                   2
ELEM 5    1    1    1023 5    2                   List of Link Types in Base Namespace
ELEM 5    1    1    1023 5    1                   List of Link Types in Base Namespace
LINK 5    1    1    1023 5    2    5    3    1    3025                          5179248000.000      8000 
LINK 5    1    1    1023 5    2    5    3    1    3024                          5179248000.000      9000 
LINK 5    1    1    1023 5    3    5    4    1    4024                          5179248000.000           
LINK 5    1    1    1023 5    1    5    2    1    2023                          5179248000.000           
ELEM 2    2    1    542  2    5                   Listed below are Link Types in the base specification
ELEM 2    2    1    542  2    4                   Intro to Link Type List
LINK 2    2    1    542  2    3    5    1    1    1023                          5179248000.000           
ELEM 2    2    1    543  2    5                   Listed below are Table Elements in the base specification
ELEM 2    2    1    543  2    4                   Intro to Table Elements
LINK 2    2    1    543  2    3    5    1    1    1025                          5179248000.000           
LINK 2    2    1    543  2    3    5    1    1    1005                     2    5179248000.000           
ELEM 2    2    1    546  2    5                   The standard Message Definition is shown below.  Each Message Element is identified by a numeric code.  The level of indentation on the left side of the page shows the hierarchical position of each Message Element.  The description for the Message Elements is on the right side of the page.
ELEM 2    2    1    546  2    4                   Message Definition Introduction
LINK 2    2    1    546  2    5    7    1    1    101                           5179248000.000           
ELEM 2    2    1    561  2    4                   Base Object Element Values List
ELEM 2    2    1    561  2    5                   Listed below are values for the Base Object Elements Values.  The column headings correspond to the Table Elements found in Appendix 5.
LINK 2    2    1    561  2    4    6    1    1    1050                          5179248000.000           
ELEM 2    2    1    562  2    4                   Base Type Values List
ELEM 2    2    1    562  2    5                   Listed below are Type Values from the Base Specification.  The numbers in the column headings correspond to Table Elements listed in Appendix 5.
LINK 2    2    1    562  2    4    6    1    1    1051                          5179248000.000           
ELEM 2    2    1    564  2    4                   Base Links List
ELEM 2    2    1    564  2    5                   Listed below are Links from the Base Specification.  The numbers in the column headings correspond to Table Elements listed in Appendix 5.
LINK 2    2    1    564  2    4    6    1    1    1052                          5179248000.000           
ELEM 6    1    1    1001 6    3                   Overview Graphic
ELEM 6    1    1    1001 6    5                   600
ELEM 6    1    1    1001 6    4                   1000
ELEM 6    1    1    1001 6    2                   Overview Graphic
ELEM 6    1    1    1001 6    1                   Overview Graphic
LINK 6    1    1    1001 6    1    3    39   1    39000                         5179248000.000           
ELEM 2    2    1    206  2    4                   Design Goals List Description
ELEM 2    2    1    206  2    5                   The specification for the ZT Server was developed with a set of Design Goals. An implementation of the specification for ZT Server along with certain core client applications (specified separately) should have the following capabilities:
TYPE 2    2    1    206  2    2    2    3              
LINK 2    2    1    206  2    2    2    2    1    207                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    208                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    209                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    213                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    214                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    215                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    216                           5179248000.000           
LINK 2    2    1    206  2    2    2    2    1    217                      2    5179248000.000           
ELEM 5    1    1    1050 5    1                   
ELEM 5    1    1    1050 5    2                   
ELEM 5    1    1    1050 5    3                   Goals for document itself
ELEM 2    2    1    567  2    4                   Goals for document itself
ELEM 2    2    1    567  2    5                   In addition, listed below are goals for the specification document itself:
TYPE 2    2    1    567  2    2    2    3              
LINK 2    2    1    567  2    2    2    2    1    568                           5179248000.000      10000
LINK 2    2    1    567  2    2    2    2    1    569                           5179248000.000      9000 
ELEM 2    2    1    207  2    4                   Design Goal #1
ELEM 2    2    1    207  2    5                   It should be possible to build applications with minimal programming using generically defined objects.
ELEM 2    2    1    208  2    5                   Applications should be multi-language (human) without having to do any special coding.
ELEM 2    2    1    208  2    4                   Design Goal #2
ELEM 2    2    1    209  2    5                   It should be possible to extend ZT Server applications and combine them with other ZT Server applications with minimal or no coding.
ELEM 2    2    1    209  2    4                   Design Goal #3
ELEM 2    2    1    213  2    4                   Design Goal #4
ELEM 2    2    1    213  2    5                   Applications should have access to a complete change history without coding.  Objects that are linked to older versions of other objects should have access to the older values even if a new version of the object being linked to has changed.
ELEM 2    2    1    214  2    5                   It should be easy for users to share data and applications with each other.
ELEM 2    2    1    214  2    4                   Design Goal #5
ELEM 2    2    1    215  2    5                   It should be easy to identify the source of any objects in the system.  It should also be easy to remove unwanted objects that were previously imported or created based on source or other criteria.
ELEM 2    2    1    215  2    4                   Design Goal #6
ELEM 2    2    1    216  2    4                   Design Goal #7
ELEM 2    2    1    216  2    5                   The design should be understandable and accessible.  A person should be able to move from being an application user to application configurator to application developer to client or server developer in a natural progression.
ELEM 2    2    1    217  2    5                   It should be possible to implement the design with a reasonable amount of effort using industry standard protocols and products that are available in open source implementations.
ELEM 2    2    1    217  2    4                   Design Goal #8
ELEM 2    2    1    568  2    4                   
ELEM 2    2    1    568  2    5                   The document should be translatable from English to other languages without using characters from the English alphabet.
ELEM 2    2    1    569  2    4                   doc goal 2
ELEM 2    2    1    569  2    5                   It should be possible to implement the design with a reasonable amount of effort using industry standard protocols and products that are available in open source implementations
ELEM 2    2    1    393  2    5                   Object Elements can also refer to an extended key to handle values that are, for example, language dependent.
ELEM 2    2    1    393  2    4                   Data Organization aspect #5
ELEM 2    2    1    392  2    5                   The common base key structure utilizes a timestamp to indicate the effective time for that row so that multiple versions of an object can be maintained
ELEM 2    2    1    392  2    4                   Data Organization aspect #4
ELEM 2    2    1    391  2    5                   Links from one object to another are used to make it possible to extend an Object to include the elements of another Object
ELEM 2    2    1    391  2    4                   Data Organization aspect #6
ELEM 2    2    1    390  2    5                   Objects share a common base key structure using a subset of the Table Elements
ELEM 2    2    1    390  2    4                   Data Organization aspect #3
ELEM 2    2    1    389  2    5                   The Table Elements are common to all objects
ELEM 2    2    1    389  2    4                   Data Organization aspect #2
ELEM 2    2    1    451  2    5                   Objects can refer to other Objects using a Type relationship.  The Type relationship allows objects to be categorized based on Type Value.
ELEM 2    2    1    451  2    4                   Data Organization aspect #7
ELEM 2    2    1    452  2    5                   Access to Object Elements, Links and Type Values is controlled via Object Templates
ELEM 2    2    1    452  2    4                   Data Organization aspect #8
ELEM 2    2    1    486  2    4                   Data Organization aspect #9
ELEM 2    2    1    486  2    5                   Every piece of object data has a namespace that identifies where the data originated from.  Inside of each ZT Server environment these namespaces are associated with codes to indicate the namespace in that environment.  These are referred to as the ZT Instance Codes or ZTICs.
ELEM 2    2    1    388  2    5                   Object data is accessed through a set of Object Elements and the data is stored in Table Elements
ELEM 2    2    1    388  2    4                   Data Organization aspect #1
ELEM 5    1    1    1005 5    1                   List of Base Table Elements for Objects
ELEM 5    1    1    1005 5    2                   List of Base Table Elements for Objects
ELEM 5    1    1    1005 5    3                   2
LINK 5    1    1    1005 5    1    5    2    1    2008                          5179248000.000           
LINK 5    1    1    1005 5    2    5    3    1    3009                          5179248000.000           
LINK 5    1    1    1005 5    2    5    3    1    3008                          5179248000.000           
LINK 5    1    1    1005 5    3    5    4    1    4008                          5179248000.000           
ELEM 2    2    1    455  2    5                   Links from the Set Definition to individual objects.  Any object linked to using this Link Type, Code 13, is included as a member.
ELEM 2    2    1    455  2    4                   Set Membership--Item 2
ELEM 2    2    1    456  2    4                   Set Membership--Item 1
ELEM 2    2    1    456  2    5                   Links from the Set Definition to an Object Kind to include all objects of that Kind as members.  This is Link Type Code 12.
ELEM 2    2    1    457  2    4                   Set Membership--Item 3
ELEM 2    2    1    457  2    5                   Links from the Set Definition to a Type Value Based Object Set to include all objects that have a Type Value in the Type Value Based Object Set as members.  This is Link Type Code 14.  The link to a Type Value Based Object Set can also refer to Type Values that are further up the type hierarchy. For example if there is an object kind for animals including lions, tigers, cheetahs, wolves, bears, fish and lobsters. A type table for animals could include cats, non-cats and sea creatures. A type table for that could include mammals and non-mammals. The Set Definition could be linked to a Type Value Based Object Set that includes the type values mammals. This would cause the animals lions, tigers, cheetahs, wolves and bears to be included as set members.
ELEM 2    2    1    458  2    4                   Set Membership--Item 4
ELEM 2    2    1    458  2    5                   Links from the Set Definition to a Template Set to include all objects using a Template in that Template Set as members.  This is Link Type Code 15.
ELEM 2    2    1    459  2    4                   Set Membership--Item 5
ELEM 2    2    1    459  2    5                   Links from the Set Definition to a Link Target Type to include all objects linked to with a link using that Link Target Type are included as members of the Set.  This is Link Type Code 16.
ELEM 2    2    1    460  2    4                   Set Membership--Item 6
ELEM 2    2    1    460  2    5                   Links from the Set Definition to a Generic Object Element Value to include all objects containing Object Elements with that value as members.  This is Link Type Code 17.
ELEM 2    2    1    462  2    4                   Set Membership--Item 8
ELEM 2    2    1    462  2    5                   Links from the Set Definition to a Set Definition to include target set members as members if also included in source set.  This uses an AND Condition (Intersection of Sets)  This is Link Type Code 19.
ELEM 2    2    1    463  2    4                   Set Membership--Item 9
ELEM 2    2    1    463  2    5                   Links from the Set Definition to a Set Definition to remove target set members as members of the source set (NOT Condition).  This is Link Type Code 20.
ELEM 2    2    1    464  2    4                   Set Membership--Item 10
ELEM 2    2    1    464  2    5                   Links from the Set Definition to a Custom Function to determine which objects will be included as members.  This is Link Type Code 21.
ELEM 2    2    1    465  2    4                   Set Membership--Item 11
ELEM 2    2    1    465  2    5                   Links from the Set Definition to a Namespace so that all objects that have an Object Kind with the ZT Namespace linked to are included as member.  This is Link Type Code 23.
ELEM 2    2    1    461  2    4                   Set Membership--Item 7
ELEM 2    2    1    461  2    5                   Links from the Set Definition to a Set Definition to include the target set members as members of source set using an OR Condition or (Union of Sets).  This is Link Type Code 18.
ELEM 2    2    1    466  2    4                   Set Membership--Item 12
ELEM 2    2    1    466  2    5                   Links from the Set Definition to a Namespace where all objects that have an Object ZT Namespace linked to are included as members.  This is Link Type Code 24.
ELEM 2    2    1    560  2    4                   Set Membership--Item 13
ELEM 2    2    1    560  2    5                   Links from the Set Definition to Generic Objects to include the objects the Generic Object refers to as members. This is Link Type Code 30.
ELEM 6    1    1    1002 6    2                   versioning master data
ELEM 6    1    1    1002 6    1                   versioning master data
ELEM 6    1    1    1002 6    3                   Master Data
ELEM 6    1    1    1002 6    4                   1000
ELEM 6    1    1    1002 6    5                   600
LINK 6    1    1    1002 6    1    3    39   1    39001                         5179248000.000           
ELEM 6    1    1    1003 6    1                   Master Data copied in
ELEM 6    1    1    1003 6    2                   Master Data copied in
ELEM 6    1    1    1003 6    3                   Master Data copied in
ELEM 6    1    1    1003 6    4                   1000
ELEM 6    1    1    1003 6    5                   250
LINK 6    1    1    1003 6    1    3    39   1    39002                         5179248000.000           
ELEM 6    1    1    1004 6    1                   versioning sales order with timestamps
ELEM 6    1    1    1004 6    2                   versioning sales order with timestamps
ELEM 6    1    1    1004 6    3                   versioning sales order with timestamps
ELEM 6    1    1    1004 6    4                   1000
ELEM 6    1    1    1004 6    5                   1200
LINK 6    1    1    1004 6    1    3    39   1    39003                         5179248000.000           
ELEM 6    1    1    1006 6    1                   ZT Instances Developer #2
ELEM 6    1    1    1006 6    2                   ZT Instances Developer #2
ELEM 6    1    1    1006 6    3                   ZT Instances Developer #2
ELEM 6    1    1    1006 6    4                   1000
ELEM 6    1    1    1006 6    5                   1200
LINK 6    1    1    1006 6    1    3    39   1    39005                         5179248000.000           
ELEM 6    1    1    1007 6    3                   DS Instances Developer #3
ELEM 6    1    1    1007 6    5                   1200
ELEM 6    1    1    1007 6    4                   1000
ELEM 6    1    1    1007 6    2                   DS Instances Developer #3
ELEM 6    1    1    1007 6    1                   DS Instances Developer #3
LINK 6    1    1    1007 6    1    3    39   1    39006                         5179248000.000           
ELEM 6    1    1    1005 6    1                   ZT Instances Developer #1
ELEM 6    1    1    1005 6    2                   ZT Instances Developer #1
ELEM 6    1    1    1005 6    3                   ZT Instances Developer #1
ELEM 6    1    1    1005 6    4                   1000
ELEM 6    1    1    1005 6    5                   1200
LINK 6    1    1    1005 6    1    3    39   1    39004                         5179248000.000           
ELEM 2    2    1    379  2    5                   The protection code table is used to declare the different levels of protection.  The table below shows the standard codes.
ELEM 2    2    1    379  2    4                   Protection Code--Paragraph #1
ELEM 2    2    1    378  2    5                   This table serves as the type table for protection codes.  The standard types are create, change, query and physical delete.  Protection codes of type create are different from the others in that it grants the ability to do something rather than prevents it.  For example if a DSI is linked to a code of type create, it allows objects from that DSI to be created.  This can come into play also for DSI of the sender.
ELEM 2    2    1    378  2    4                   Protection Type--Paragraph #1
ELEM 2    2    1    375  2    5                   The Protection Profile Type table is used to separate the profiles into their separate usages.  The types have link Functions associated that specify that a profile of a specific type, there will be mandatory links or optional links to protection codes of a certain type.  The standard profile types are listed below.
ELEM 2    2    1    375  2    4                   Protection Profile Type--Header #1
ELEM 2    2    1    373  2    5                   The protection profile table is used to combine a set of protection codes.  Links are created from the protection profile to the protection codes it includes.  Links are created from object kinds, object type definitions, DSIs and users to the protection profile they use.  The protection codes that the profile is linked to define the behavior of the protection.  The specific meaning of the codes are explained under the protection code table.  Protection profiles types and codes can only be maintained by an administrative user.
ELEM 2    2    1    373  2    4                   Protection Profile--Paragraph #1
ELEM 2    2    1    371  2    5                   This section describes the concepts used to protect data from unwanted update.
ELEM 2    2    1    371  2    4                   Data Protection Introduction--Paragraph #1
ELEM 6    1    1    1002 6    2                   versioning master data
ELEM 6    1    1    1002 6    1                   versioning master data
ELEM 6    1    1    1002 6    3                   Master Data
ELEM 6    1    1    1002 6    4                   1000
ELEM 6    1    1    1002 6    5                   600
LINK 6    1    1    1002 6    1    3    39   1    39001                         5179248000.000           
ELEM 6    1    1    1003 6    1                   Master Data copied in
ELEM 6    1    1    1003 6    2                   Master Data copied in
ELEM 6    1    1    1003 6    3                   Master Data copied in
ELEM 6    1    1    1003 6    4                   1000
ELEM 6    1    1    1003 6    5                   250
LINK 6    1    1    1003 6    1    3    39   1    39002                         5179248000.000           
ELEM 6    1    1    1004 6    1                   versioning sales order with timestamps
ELEM 6    1    1    1004 6    2                   versioning sales order with timestamps
ELEM 6    1    1    1004 6    3                   versioning sales order with timestamps
ELEM 6    1    1    1004 6    4                   1000
ELEM 6    1    1    1004 6    5                   1200
LINK 6    1    1    1004 6    1    3    39   1    39003                         5179248000.000           
ELEM 6    1    1    1006 6    1                   ZT Instances Developer #2
ELEM 6    1    1    1006 6    2                   ZT Instances Developer #2
ELEM 6    1    1    1006 6    3                   ZT Instances Developer #2
ELEM 6    1    1    1006 6    4                   1000
ELEM 6    1    1    1006 6    5                   1200
LINK 6    1    1    1006 6    1    3    39   1    39005                         5179248000.000           
ELEM 6    1    1    1007 6    3                   DS Instances Developer #3
ELEM 6    1    1    1007 6    5                   1200
ELEM 6    1    1    1007 6    4                   1000
ELEM 6    1    1    1007 6    2                   DS Instances Developer #3
ELEM 6    1    1    1007 6    1                   DS Instances Developer #3
LINK 6    1    1    1007 6    1    3    39   1    39006                         5179248000.000           
ELEM 6    1    1    1005 6    1                   ZT Instances Developer #1
ELEM 6    1    1    1005 6    2                   ZT Instances Developer #1
ELEM 6    1    1    1005 6    3                   ZT Instances Developer #1
ELEM 6    1    1    1005 6    4                   1000
ELEM 6    1    1    1005 6    5                   1200
LINK 6    1    1    1005 6    1    3    39   1    39004                         5179248000.000           
ELEM 2    2    1    473  2    5                   The Response QueryResponeSet is a section of the message where all the objects that were queried by the client are listed by the server based on the template used in the query.  The ID and ParentID Message Elements are used to convey the hierarchy of objects that resulted from links from parent objects to child objects
ELEM 2    2    1    473  2    4                   Response QueryResponseSet--Paragraph #1
ELEM 2    2    1    472  2    5                   The Message Response MaintainResponseSet contains data populated by the server about objects that were maintained on the server.  Of particular importance, it provides a mechanism for the server to let the client know what new codes were assigned to newly created objects in the target namespace and the related temporary codes that were assigned by the client until object creation was completed by the server.
ELEM 2    2    1    472  2    4                   MaintainSetResponse--Paragraph #1
ELEM 2    2    1    431  2    4                   Request QuerySet Paragraph #1
ELEM 2    2    1    431  2    5                   The TimestampSet, Message Element 3104, is an optional element used to specify the timestamp or the range of timestamps being selected.  If no TimeStamp is included the sever uses current time for the selection.  Message Element 31040 is a child of 3104 and has two child elements, operator and value, Message Elements 31041 and 31042.  The allowed operators are ==, <=, >=, <, or > which correspond to equal, less than or equal, greater than or equal, less than, or greater than.  To specify a range of timestamps, two TimeStampEffective elements should be used, one to contain the lower boundary with a > or >= operator and one for the upper boundary with a < or <= operator.  The value element can contain a timestamp or -999999999 ... to represent the beginning of time or 9999999999 ... to represent the end of time.  The value of ! is used to represent current time.  the value of @ is used to represent a day.  The plus, minus, * (for multiplication) or / (for division) symbols can also be used in conjunction with the current time.  Parenthesis can be used to indicate precedence for calculation.  For example, a value of !+3600 represents one hour after the current time.  A value of !-3600 represents one hour before the current time.  For example !-(@*3)would mean 3 days before the current time.  When calculating the seconds for a timestamp using days it would be adjusted for leap seconds if they exist in the time period being calculated.
ELEM 2    2    1    432  2    4                   Request QuerySet Paragraph #2
ELEM 2    2    1    432  2    5                   The Selection section of the Query is used to specify which data should be selected.  The first node under Selection node is called groupNumber.  This is a 4 digit numeric value.   Selections with the same group number are treated as AND relationships.  Selections when the group number differs are treated as OR.  This means that is if there are two groups that select object that have the same group number, the server will only return objects that the two selections have in common.  If the group numbers differ, the server will return the objects if the result from the selection of either group.  Under the Object element is the Level element which indicates where is the hierarchy the Object resides.  For an object at the top of the hierarchy, this would be given a value of 0.  The next level down would have a value of 1.  Typically the level in the selection would 0.  There may be cases when it may be somewhere else.  For example, suppose a group of financial documents is being selected based on line item amount.  Object Elements are selected using a selection operator.  The allowed operators are ==, <=, >=, <, or >, =*, *= and *=* which correspond to equal, less than or equal, greater than or equal, less than, greater than, begins with, ends with and contains.  To select all documents with a value greater than $100.00.  For this example, assume that the financial document uses an object kind for header and another object kind for line items which contains the amounts.  In this case, the selection that contains the amount being compared is stored one level down from top level (level 1).  The server could do a selection on the line items table and find all postings that are greater than 100.00.  The selection would specify that selection is based on the link type of financial document header to financial document line item.  In this case the links need to be queried in reverse to find all of the header objects that are linked to line item objects that or 100.00 or more
ELEM 2    2    1    433  2    4                   Request QuerySet Paragraph #0
ELEM 2    2    1    433  2    5                   The QuerySet, Message Element 31, section of the request contains information about data that the client wishes to retrieve from the server.  The first node under the QuerySet element is Query, Message Element 310.  There can be 1 to many Query nodes in the QuerySet.  Each Query contains an ID in Message Element 3100.  The value in the ID field is assigned by the client.  The same value is returned by the server under the QueryResponse in Message Element 4100.  Message Elements 3101 and 3102 hold the Template ZTIC and Template Code which determines the object values returned in the response.  Message Elements 31030 and 31031 hold the ZTIC and Code of the selection mode.  The mode indicates, for example, if only current values are selected (mode 1) or a complete history of values is selected (mode 2).  Message Element 31032 has status values that should be excluded from a response, for example objects with an inactive status could be excluded. Message Element 3104, described in the next paragraph, relates to timestamps. Message Element 3105 is the parent query response control parameters. Message Element 3107 has selection parameters that can be used, for example, when an object element has a calculated value.   Message Element 3110 is the parent for selection sets.
ELEM 2    2    1    434  2    4                   Request QuerySet Paragraph #3
ELEM 2    2    1    434  2    5                   The selections determine what objects are returned by the query but  the the data content of the objects.  The data content is determined by the object templates used for selection.
ELEM 2    2    1    430  2    4                   Request MaintainSet Paragraph #2
ELEM 2    2    1    430  2    5                   The ObjectSet, Message Element Code 3030, and its children contain the object data to be created or updated on the server.  If the newCode Message Element 3036 is set to + (true), this indicates that the Server should generate a new object code on the server.  In this case the  code is a temporary code only used in the context of the message.
ELEM 2    2    1    429  2    4                   Request MaintainSet Paragraph #1
ELEM 2    2    1    429  2    5                   The Request MaintainSet, Message Element Code 30, is populated by the Client as part of a Request Message and it contains data needed to create or update objects on the ZT Server.  It contains an ID, Message Element Code 3000, that is returned in the Response in Message Element Code 4000 and a Default Effective Timestamp, Code 3003.  The ZTIC and Code of the Update Mode in Message Elements 30080 and 30081.
ELEM 2    2    1    427  2    4                   Message Definition--Header paragraph #2
ELEM 2    2    1    427  2    5                   The ZTISet section, Message Element 21, is used to declare all of the ZT Instance Codes that are used in the Message Request or Response and the associated Namespaces.  It must contain the namespace 131131/22 and its associated ZT Instance Code to indicate the ZT Instance Code of the Message Definition.  The ZT Instance Codes declared here are local to the message.  The Server will maintain a different set of ZT Instance Codes and namespaces.  The Codes need to be converted during message processing.
ELEM 2    2    1    426  2    4                   Message Definition--Header paragraph #1
ELEM 2    2    1    426  2    5                   The Message Header contains data needed to control processing of the message.  It is populated primarily by the Client as part of the Request but the Server also updates some Message Elements during the Response. The first section of the Header is called MessageDefinition which is used to refer to the Message Definition that is used to validate the syntax of the message.  As this implies, it is possible for the Message to refer to a non-standard Message Definition.  However, any alternate Message Definition must still contain the standard Message Elements for the Message Definition and the Message Elements in following standard section called ZTISet.
ELEM 2    2    1    428  2    4                   Message Definition--Header paragraph #3
ELEM 2    2    1    428  2    5                   The Message Processing Parameters, Message Element 23, is used by the client to transfer instructions for how the message will be processed including default values described in the Message Definition.  The ExtendedKeySet, Message Element 231, allows the client to indicate which Extended Key value to be used to access Object Elements that use extended keys, for example language dependent Object Elements.  Message Elements 233 is used queue processing if queue processing (processing of messages in a specific order) is supported by the server.
ELEM 2    2    1    398  2    5                   The Message Definition describes the structure of messages transferred between the client and the server.  The complete definition is shown in Appendix 6 which contains the Message Element Codes and Message Element Descriptions referred to in this section of the specification.  The hierarchical relationship of the Message Elements in Appendix 6 is shown by the level of indentation for each Message Element.  The Message Definition is divided into three major sections, Header, Request and Response which appear under the Message Root.  The Message Definition contains numeric Message Element Codes that are referred to by the message.  The Root Message Element Code is 1.  the Header Message Element Code is 2.  The Request Message Element Code is 3 and the Response Message Element Code is 4.  The Message Element Codes are constructed to provide a rough navigation aid.  The Codes for all of the children Message Elements share the the same beginning codes as the parent Message Element.  Further down the hierarchy this pattern is not followed in all cases.
ELEM 2    2    1    398  2    4                   Message Definition Introduction
ELEM 6    1    1    1010 6    4                   800
ELEM 6    1    1    1010 6    5                   500
ELEM 6    1    1    1010 6    2                   Communication Message Structure
ELEM 6    1    1    1010 6    3                   Communication Message Structure
ELEM 6    1    1    1010 6    1                   Communication Message Structure
LINK 6    1    1    1010 6    1    3    39   1    39009                         5179248000.000           
ELEM 2    2    1    415  2    4                   Message Processing Step #10
ELEM 2    2    1    415  2    5                   The Response Message is returned to the calling client
ELEM 2    2    1    414  2    4                   Message Processing Step #9
ELEM 2    2    1    414  2    5                   The Server creates the Message segments of the Response, converting the ZT Instance Codes used in the Server to the ZT Instance Codes used in the message.
ELEM 2    2    1    413  2    5                   The Server evaluates entries in the QuerySet section of the Request Message and selects the appropriate object data from the database and places is in the internal representation of the Message.
ELEM 2    2    1    413  2    4                   Message Processing Step #8
ELEM 2    2    1    412  2    5                   The Server updates validated data from the MaintainSet section of the Request to the database.
ELEM 2    2    1    412  2    4                   Message Processing Step #7
ELEM 2    2    1    411  2    4                   Message Processing Step #6
ELEM 2    2    1    411  2    5                   The Server applies Application validations to object in the Message MaintainSet.  If any validations fail, update of the data is stopped and validation error messages are returned in the Message Response.
ELEM 2    2    1    410  2    4                   Message Processing Step #5
ELEM 2    2    1    410  2    5                   The Server validates objects data sent in the MaintainSet section of the Request Message.  For example it checks that Object Kinds referred to in the Message exist in the Server.  It also checks that all Object Element Values, Type values and Links conform to Object Elements, Type Definitions and Link Types included in the Object Template specified in the message.  Any validations from Data Elements that are referred to by Object Elements being used are invoked.  If any validations fail, update of the data is stopped and validation error messages are returned in the Message Response under ServerLogSystemMessageSet, Message Element 43.
ELEM 2    2    1    409  2    4                   Message Processing Step #4
ELEM 2    2    1    409  2    5                   The ZT Instance Codes are converted to the ZT Instance Codes used by the Server
ELEM 2    2    1    408  2    4                   Message Processing Step #3
ELEM 2    2    1    408  2    5                   The Server parses the message and transforms it into an internal representation determined by the server developer.
ELEM 2    2    1    407  2    4                   Message Processing Step #2
ELEM 2    2    1    407  2    5                   The Server performs a technical syntax validation to ensure that the message refers to a Message Definition that is recognized by the server, all segments are sequentially numbered and each segment refers to a valid Message Element and the Message Element of the parent segment is the correct parent per the Message Definition.
ELEM 2    2    1    406  2    4                   Message Processing Step #1
ELEM 2    2    1    406  2    5                   A Message is delivered by a client to the Server as payload by some protocol supported by the Server.
ELEM 2    2    1    474  2    5                   To clarify the concepts presented thus far, this section provides examples of message processing, starting with the simplest cases.  The first example involves sending a message to the server to create an address and then a subsequent message to query the address.  As the first step, suppose a ZT Client application uses the screen below to capture the address data.
ELEM 2    2    1    474  2    4                   Introduction--Paragraph #1
LINK 2    2    1    474  2    4    6    1    1    1038                          5179248000.000           
ELEM 2    2    1    478  2    5                   Continuing to Segment Id 2, we see that the Id of the Parent is 1, which means it is a child of the root Message Element.  If we look at the Message Definition in Appendix 6, we see that Message Element 2 is for the message Header.  Header is also a node that has child Message Elements and therefore has no value itself.  Segment Id 3 is a child of 2 (Header) and has Message Element Code 20 which the Message Definition indicates is the node for declaring the template and code for the Message Definition.  Again, this is a node and has no value itself.  Segment Ids 4 through 7 refer to Message Elements 200 through 203.  These are not nodes but rather are Message Elements that could contain values for the Message Definition Template ZTIC/Code the Message Definition ZTIC/Code.  These are children of Segment Id 3 (Message Element 20).  For this example, Message Elements 200 through 203 are blank and the server then assumes that the message definition from the base specification should be used.
ELEM 2    2    1    478  2    4                   Address Create Example--Paragraph #4
ELEM 2    2    1    482  2    5                   The next graphic is a continuation of the previous which shows an example message to create an address.  Segment Ids 29 through 40 were omitted because they are additional ZTIC-namespace pairs that are not needed for this example.
ELEM 2    2    1    482  2    4                   Address Create Example--Paragraph #7
LINK 2    2    1    482  2    4    6    1    1    1009                          5179248000.000           
ELEM 2    2    1    483  2    5                   Segment Id 41 is a child of Segment Id 2, which contains the Header.  It has message element 22 which is used for message partners.  It is a node with child elements and holds no value itself.  Segment Id 42 is a child of Segment Id 41 and refers to Message Element 223 which is for the Receiver ZTIC.  The server uses the Receiver ZTIC to determine which Server DB--ZT Instance ID to use when storing message data.  The Receiver ZTIC in this case is 1.  In the ZTIC-Namespace declarations, ZTIC is associated with namespace zt_abc.com/test1 in Segment Id 17. The server keeps track of the namespace for each Server DB--ZT Instance ID that it handles.  If the zt_abc.com/test1 namespace is associated with a Server DB--ZT Instance ID that the server handles, it will use that Server DB--ZT Instance ID to store the data.  The Server DB--ZT Instance ID is stored in Table Element 32.
ELEM 2    2    1    483  2    4                   Address Create Example--Paragraph #8
ELEM 2    2    1    484  2    5                   Segment Id 43 through 49 are children of Segment Id 10  for Message Element 230, General Message Processing Parameters.  Segment Id 43 is for Message Element 2301 which holds the default timestamp.  Segment Id 44 has Message Element 2302 which hold the client message Id.  Message Id 45 has Message Element 2303 which is the last segment Id of the request message.  This is used to indicate which was the last segment Id populated by the client.  subsequent segments are populated by the server.  Last segment Id in the request is an unimplemented feature in this example and 1234 is used as a placeholder.  The value should be 92.  Segment Id 46 which has Message Element 2304 has the default update mode which is applied if not specified in a MaintainSet.  Segment Id 47 which has Message Element 2305 has the user name a value.  The user must be authenticated by the client before passing the message to the server.  Segment Ids 48 and 49 have the ZTIC and code of the ServerSoftwareRuntimeProfile which is used to determine which server software patch level to use when processing the message.
ELEM 2    2    1    484  2    4                   Address Create Example--Paragraph #9
ELEM 2    2    1    475  2    5                   To create an address on a server, it is necessary for the client to send a message with address data to the server.  For the message to successfully process, there needs to already exist on the server all of the objects needed for address definition.  This example assumes that these objects already exist on the server.  The table below show what the initial message with address data would look like.
ELEM 2    2    1    475  2    4                   Address Create example--Paragraph #1
LINK 2    2    1    475  2    4    6    1    1    1008                          5179248000.000      10000
ELEM 2    2    1    476  2    5                   The graphic shows a request message to create an address.  This shows the structure of the message as it is communicated.  The first column, SegId is a sequentially assigned identifier for the segment.  The Parent column has the Id number of the parent segment.  Prio (Priority) is optional and can be used to assign priority when two child segments share the same parent.  The ElemZTIC has the ZTIC of the Message Element that this segment refers to.  The ElemCode has the Message Element Code that the segment refers to.  Value indicates the data value used by the segment for segments that can hold a value.  The Message Element ZTIC and Message Element Code shown here refers to a Message Definition.  The Message Definition for the base standard is shown in Appendix 6.  All of the segments in this example refer to standard Message Elements so they all use the same ElemZTIC, 4, which represents namespace 131131/22, the namespace used for standard Message Elements.
ELEM 2    2    1    476  2    4                   Address Create Example--Paragraph #2
ELEM 2    2    1    477  2    5                   If we look at the first segment of the message, with segment ID 1, we notice that the parent segment is 0 which means that this segment has no parent and is the root segment.  The Prio (Priority) column is not relevant to this example.  The ElemZTIC is the same for all segments because all come from the base specification.  The ElemCode (Message Element Code) is a reference to the Message Definition found in Appendix 6.  In this case ElemCode 1 refers to the root element of the Message Definition.  The Value column for segment Id 1 is blank because the root Message Element is a node which serves as the parent for other Message Elements and cannot hold data itself.
ELEM 2    2    1    477  2    4                   Address Create Example--Paragraph #3
ELEM 2    2    1    479  2    5                   Segment Id 8 refers to Message Element 21, which is a child node of Header, because segment Id of the parent is 2.  Message Element 21 is a node that is a parent for declarations of ZTI Codes and namespaces used in the context of the message.  Segment Ids 9 through 16 are additional nodes that are parents of other Message Elements used further down the message.  These include 23 (Segment Id 9) for Message Processing Parameters, 230 (Segment Id 10) for General Processing Parameters, 231 (Segent Id 11) for Extended Key Sets, 3 (Segment Id 12) for the top level of the Request Section, 30 (Segment Id 13) for top of the MaintainSet Section, 31 (Segment Id 14) for top of the QuerySet, 32 (Segment Id 15) for RequestMessageStatusSet and 33 (Segment Id 16) for ClientLogMessageSet.
ELEM 2    2    1    479  2    4                   Address Create Example--Paragraph #5
ELEM 2    2    1    481  2    5                   Message Segment ID 17 begins the declaration of the first ZTIC namespace pair.  The ZTIC is in segment Id 18 with Message Element Code 2100 and a value of 1.  The namespace is in Segment Id 19 with Message Element  2101 and a value of zt_abc.com/test1.  These ZTICs and namespace relationships are only valid within the context of this message.  When the message is processed, for example by a server, the ZTICs need to be converted to the values used on the receiving server.  Segment Ids 20 through 28 are used to declare other ZTICs and namespaces following that same pattern.
ELEM 2    2    1    481  2    4                   Address Create Example--Paragraph #6
ELEM 2    2    1    495  2    4                   Address Create Example--Paragraph #10
ELEM 2    2    1    495  2    5                   Segment Id 50 for Message Element 2310 is a child of Segment Id 11 and is the parent segment for an Extended Key and key value.  Segment Id 51 for Message Element 2311 contains the Extended Key Definition Code ZTIC.  This contains a value of 2 which is the code of the base namespace.  Segment Id 52 for Message Element 2312, Extended Key Definition Code has a value of 2 indicating that it is the extended key for language. Segment Id 53 for Message Element 2313, Extended Key Value ZTIC has a value of 2, the code for the base namespace.  Segment Id 54 for Element 2314, Extended Key Value Code, has a value of 1, indicating language English.  This means that any Object Elements that use the Extended Key for language will be recorded with the key for the English language.
ELEM 2    2    1    496  2    4                   Address Create Example--Paragraph #11
ELEM 2    2    1    496  2    5                   Segment Id 55 for Message Element 300 is a child of Segment Id 13, Message Element 30 for Maintain Set which contains Maintain nodes.  Segment Id 56 for Message Element 3000 is a child of Segment Id 55 and contains the identifier of the Maintain node.  In this case the Identifier is MaintainSetId#1.  Message Id 59 for Message Element 3003, contains the Default Effective TimeStamp for the message update.  Message Id 61 for Message Element 3030, named Object Set is the parent Message Element for object data that will be created or updated by the message.
ELEM 2    2    1    497  2    4                   Address Create Example--Paragraph #12
ELEM 2    2    1    497  2    5                   The next graphic shows the remaining segments from the Request portion of the message.
LINK 2    2    1    497  2    4    6    1    1    1020                          5179248000.000           
ELEM 2    2    1    498  2    4                   Address Create Example--Paragraph #13
ELEM 2    2    1    498  2    5                   Segment Id 62 for Message Element 3031 is a child of Segment Id 61 and is the parent for the object identifiers of an object being maintained.  Segment Id 63 for Message Element 3032 for Object Kind ZTIC contains a value of 3 which corresponds to namespace zinfinitree.com/address.  The server converts the namespace zinfinitree.com/address to the ZT Instance Code that corresponds to the zinfinitree.com/address on the server and then updates the converted code into table element 1.  Segment Id 64 for Message Element 3033 for Object Kind Code contains a value of 1.  This the code of the Object Kind for Address within the Address application which was defined within namespace zinfinitree.com/address.  Segment Id 65 Message Element 3034 for Object ZTIC has a value of 1 which corresponds to namespace abc.com/test1, the target namespace of the message where the new address is to be created.  Segment Id 66 for Message Element 3035 for Object Code Temp.  This has a value of 1 which a temporary code used only within the context of the message.  The actual code is assigned by the server as the message is processed.  Segment 67 for Message Element 3036 has a value of + which is a boolean that indicates that this is a newly created object that will be assigned a code by the server.  Segments 68 and 69 for Message Elements 3037 and 3038 can be used to indicate hierarchy for multi-level objects.  Segments Id 70 for Message Element 30390 for Template ZTIC.  This has a value of 3 which corresponds to namespace zinfinitree.com/address.  Segment Id 71 for Message Element 30391 for Template Code with a value of 1, a Template defined within the Address application.  Segment Id 72 for Message Element 3040 for Element Set which is the parent for Object Element values being maintained.
ELEM 2    2    1    499  2    4                   Address Create Example--Paragraph #14
ELEM 2    2    1    499  2    5                   Segment Id 73 for Message Element 3041 for Element is the parent for a single Object Element value.  Segment Id 74 for Message Element 3042 for Object Element ZT Instance Code has a value 3.  This corresponds to namespace zinfinitree.com/address, the namespace for the address application.  Segment Id 75 for Message Element 3043 for Object Element Code has a value of 1.  This is code assigned to the Object Element, House Number within the address application.  One of the validations the server must perform is to ensure that if data is being maintained for an Object Element, the Object Element must already be exist in the server and be a valid Object Element for the Object Template being used to maintain the object.  Segment Id 76 for Message Element 3044 for Object Element value.  This has a value of 101, the house number for the address being created.  Segment Ids 77 to 80 follow the same pattern as Segment Ids 73 to 76.  In this case it is for Object Element Code 2 which is used for Street which has a value of Main Street.  Segments Ids 81 to 84 continue the same pattern, in this case for Object Element Code 3 for City which contains a value of Anytown.  Segment Ids 85 to 88 use the same pattern, in this case for Object Element Code 4 for State/Province with a value of ZZ.  Segment Ids 89 to 92 continue the pattern, in this case for Object Element Code 5 for Postal Code with a value of 00011.
ELEM 2    2    1    500  2    4                   Address Create Example--Paragraph #15
ELEM 2    2    1    500  2    5                   The graphic below shows the response from the server.
LINK 2    2    1    500  2    4    6    1    1    1021                          5179248000.000           
ELEM 2    2    1    501  2    5                   All of the previous message segments were populated by the client to form the Request portion of the message.  All of the remaining segments shown above were populatd by the Server to form the message Response.  Segment Id 93 for Message Element 4 is a child of Segment Id 1 for Message Element 1, the root of the entire message.  Message Element 4 is the parent for the message Response.  Segment Id 94 for Message Element 40 for Maintain Response Set is a child of Segment Id 93.  Segment Id 95 for Message Element 400 for Maintain Response is a child of Segment Id 94.  Segment Id 96 for Message Element 4030 for Object Set is the parent for objects in the Maintain Response.  Segment Id 97 for Message Element 4031 is the parent for an individual object of  the Object Set.  Segment Id 98 for Message Element 4032 for Object Kind ZT Instance Code has a value of 3 for which corresponds to zinfinitree.com/address.  This ZT Instance Code is based on the ZT Instance Codes defined within the message.  The actual ZT Instance code used to save the address on the server will be based on the ZT Instance Codes used on the server.  Segment Id 99 for Message Element 4033 for Object Kind Code.  This is the Kind Code set up for addresses in the address application defined in the zinfinitree.com/address namespace.  Segment Id 100 for Message Element 4034 for Object ZT Instance Code which has a value of 1 which corresponds to zinfinitree.com/test1 the target of the message which is the ZT Instance where the new address is created.  Segment Id 101 for Message Element 4035 for Object Code Temporary.  This is the temporary code that was sent by the client that is used to identify the object until an object code is assigned by the server.  Segment Id 102 for Message Element 4036 for Object Code Assigned has a value of 57, the code assigned by the server.
ELEM 2    2    1    501  2    4                   Address Create Example--Paragraph #16
ELEM 2    2    1    489  2    5                   The graphic below shows the updated database table on the server
ELEM 2    2    1    489  2    4                   updated database - introduction
LINK 2    2    1    489  2    4    6    1    1    1022                          5179248000.000           
ELEM 2    2    1    502  2    5                   The column headings in this example contain TE- followed by a number.  TE stands for Table Element.  The number after TE- is the code of the Table Element as shown in the Key Concepts--Introduction section of this document.  The value in the first column for TE-32, Server DB-ZT Instance Id, is derived by the server based on the namespace that corresponds to the code in Message Element 223, found in Segment Id 42.  In this case the code is 1.  The namespace that corresponds to code 1 is found in Message Element 2101, Segment Id 19 is abc.com/test1.  The server finds the Server DB--ZT Instance Id based a configuration file that relates the namespaces with Server DB--ZT Instance Id.  In this case the Server DB--ZT Instance Id is TST1.  The server applies the TST1 value to all updates related to the message.
ELEM 2    2    1    502  2    4                   updated database - Paragraph #1
ELEM 2    2    1    503  2    5                   The second column headed TE-1 hold the ZT Instance Code for the Object Kind of the Object.  The source of the data for this column is based on the value of message Segment Id 63 for Message Element 3032 which has a Object Kind ZTIC value of 3.  A conversion is performed by the server based on the namespace that this code represents.  In the message, Segment Ids 24 and 25 we see that code 3 represents namespace zinfinitree.com/address, the namespace used to develop the Address application. The graphic below shows the ZT Instance codes on the server for ZT Instance TST1.  Here we can see that the namespace zinfinitree.com/address is associated with ZT Instance Code 4.  When the server updates the table with the address data, it uses Object Kind ZTIC with the value, 4, after converting the ZTIC values from the value relevant in the message to the value relevant in the server.
ELEM 2    2    1    503  2    4                   updated database - Paragraph #2
LINK 2    2    1    503  2    4    6    1    1    1023                          5179248000.000           
ELEM 2    2    1    504  2    5                   The third column headed TE-2 holds the Object Kind Code.  This is the code assigned to the Address Object Kind in the zinfinitree.com/address application which has a value of 1.  The value was taken from Segment Id 64 for Message Element 3033.
ELEM 2    2    1    504  2    4                   updated database - Paragraph #3
ELEM 2    2    1    505  2    5                   The fourth column headed TE-3 contains the ZT Instance Code (ZTIC) of the address being created.  Because this is an object being created locally in target ZT Instance, the namespace associated with the object is the same as the namespace used to identify the target instance, abc.com/test1.  In this case, the ZTIC  associated with abc.com/test1 in the message, in Segment Id 18 and 19, is the same as the ZTIC associated with abc.com/test1 in the server (code 1) so there is no need for the server to convert the ZTIC in this case.  As a result, the server populates this column with the value 1, the value from Segment Id 65 for Message Element 3034 for Object ZTIC.
ELEM 2    2    1    505  2    4                   updated database - Paragraph #4
ELEM 2    2    1    506  2    5                   The fifth column headed TE-4, contains the Code of the newly created address.  Although a Code was provided by the client in the request message in Segment Id 66 for Message Element 3035 with a value of 1, this code was temporary.  The actual Code for the address, 57, was generated by the server, placed in TE-4 column.  The generated Code was provide to the client in the message response in Segment Id 102 for Message Element 4036.
ELEM 2    2    1    506  2    4                   updated database - Paragraph #5
ELEM 2    2    1    507  2    4                   updated database - Paragraph #6
ELEM 2    2    1    507  2    5                   The sixth column, headed TE-7, contains the Object Element ZT Instance Code.  These are Object Elements that were defined as part of the Address Application under the namespace zinfinitree.com/address, the same namespace used to define the Object Kinds.  The source of the ZTIC in the message is Segment Id 74, 78, 82, 86 and 90 for Message Element 3042 with a value of 3.  A conversion is performed by the server based on the namespace that this code represents. In the message, Segment Ids 24 and 25 code 3 represents namespace zinfinitree.com/address, the namespace used to develop the Address application.  The ZTIC associated with zinfinitree.com/address on the server is 4, so this column is populated with the 4, the same ZTIC used in the second column headed TE-1.
ELEM 2    2    1    508  2    5                   The seventh column, headed TE-8, contains Object Element Codes.  The meaning of the code was defined as part of the address application.  The source of the data in the message are Segment Ids 75, 79, 83, 87 and 91 for Message Element 3043 with values 1, 2, 3, 4 and 5.   While there could be a variety of Object Elements defined for an Object Kind, the server should only accept maintenance of Object Elements that are are included for the Object Template being used by the message being processed.
ELEM 2    2    1    508  2    4                   updated database - Paragraph #7
ELEM 2    2    1    509  2    5                   The eighth column, headed TE-9 contains the Extended Key Definition ZT Instance Code.  This column is only used if the Object Element uses an extended key.  In this example, only the Object Element for City uses Extended Key to accommodate the names of cities in multiple human languages.  The source of this ZTIC is Segment Id 51 for Message Element 2311 with a value of 2 which corresponds to the namespace 131131/21, the base namespace as shown is Segment Ids 21 and 22.  The server also uses ZTIC 2 to represent the base namespace so there is no need for the server to convert the ZTIC from the value used in the message to the value used in the server.  As a result, the value 2 is used in the table when storing the city for the address being maintained.
ELEM 2    2    1    509  2    4                   updated database - Paragraph #8
ELEM 2    2    1    510  2    5                   The ninth column headed TE-10 contains the Extended Key Definition Code.  The source of this data is Segment Id 52 for Message Element 2312.  It is used to identify which Extended Key Definition the Extended Key relates to.  In this case the Extended Key Definition is for language.  As with the eighth column, it is only populated for Object Elements that use an extended key and for this example only the Object Element for Address City can be maintained in multiple languages.
ELEM 2    2    1    510  2    4                   updated database - Paragraph #9
ELEM 2    2    1    511  2    5                   the tenth column headed TE-11 contains the Extended Key ZT Instance Code.  As with the column headed TE-9, this column is only used if the Object Element uses an extended key. In this example, only the Object Element for City uses Extended Key. The source of this ZTIC is Segment Id 53 for Message Element 2313 with a value of 2 which corresponds to the namespace 131131/21, the base namespace, as shown is Segment Ids 21 and 22.  And as with TE-9, the server also uses ZTIC 2 to represent the base namespace so there is no need for the server to convert the ZTIC from the value used in the message to the value used in the server.  As a result, the value 2 is used in the table when storing the city for the address being maintained.
ELEM 2    2    1    511  2    4                   updated database - Paragraph #10
ELEM 2    2    1    512  2    5                   The eleventh column headed TE-12 contains the Extended Key Code.  The source of this data is Segment Id 54 for Message Element 2314.  The Code 1 for the purpose of this example represents the English language, the language used for maintaining the City for this address.  This is because the Object Element for City was configured to use an Extended Key to allow storing the city name in multiple languages.
ELEM 2    2    1    512  2    4                   updated database - Paragraph #11
ELEM 2    2    1    513  2    5                   The twelfth column headed TE-26 contains the effective timestamp of the record which is the number of seconds or decimal fractions of a second elapsed since November 17, 1858, Midnight UTC, on the Gregorian calendar.  For data that was created in another namespace the timestamp would be assigned on that server managing that namespace.  Because the address is being created locally the timestamp is assigned by the local server processing the message.
ELEM 2    2    1    513  2    4                   updated database - Paragraph #12
ELEM 2    2    1    514  2    5                   The thirteenth and final column headed TE-31 contains the Object Element value that is being updated by the message.  The source of the data is Segment Id 76, 80, 84, 88 and 92 for Message Element 3044 for Object Element Value.
ELEM 2    2    1    514  2    4                   updated database - Paragraph #13
ELEM 2    2    1    515  2    5                   This section shows in detail an example message used by a client to query the address created in the previous example.  When an object is queried, it is frequently useful to also query the template of the object being queried.  For this example, both the Address Template and the Address Object are queried.  The graphic below shows the first part of the message.  The explanation for this section of the message can be taken from the Address Create example because the beginning part of the two messages are very much the same.
ELEM 2    2    1    515  2    4                   Address Query--Introduction
LINK 2    2    1    515  2    4    6    1    1    1024                          5179248000.000      10000
ELEM 2    2    1    516  2    5                   The next graphic completes the header of the message and begins filling in segments for the Query and Selection of the Address template.
ELEM 2    2    1    516  2    4                   Address Query--Paragraph #1
LINK 2    2    1    516  2    4    6    1    1    1025                          5179248000.000      10000
ELEM 2    2    1    517  2    5                   Segment Id 50 through 52 declares the namespace zt_abc.com/test1 associates it with code 12.  Segment Id 54 for Message Element 223 hold the Receiver ZT Instance Code.  It holds a value of 12 which means the the namespace of the target ZT Instance is zt_abc.com/test1.  Segment Id 55 is a child of Segment Id 10 for Message Element 230 which is the parent for General Message Processing Parameters. Segment Id 55 uses Message Element 2301 which contains a timestamp, the number of seconds or decimal fractions of a second elapsed since November 17, 1858, Midnight UTC.  In this case, the timestamp is used to determine which data will be selected for the query. Records are selected that have the most recent timestamp that is less than or equal to the selection timestamp in Message Element 2301.  Segment Id 56 for Message Element 2302 has a Message Id that is assigned by the client.  Segment Id 57 for Message Element 2303 has the Segment Id of the last segment sent by the client. Last segment Id in the request is an unimplemented feature in this example and 1234 is used as a placeholder. The value should be 112. Segment Id 58 for Message Element 2304 has the Default Update Mode which is not used in this case because the message is only for query.  Segment 59 for Message Element 2305 contain the user id. Segment Ids 60 and 61 contain the ZTIC and Code of the Server Software Runtime Profile used to process the message.
ELEM 2    2    1    517  2    4                   Address Query--Paragraph #2
ELEM 2    2    1    518  2    5                   Segment Id 62 for Message Element 2310 is a child of Segment Id 11 and it is the parent for an Extended Key.  Segment Ids 63 to 66 for Message Elements 2311, 2312, 2313 and 2314 are children of Segment Id 62 and contain the values for an Extended Key.  Message Element 2311 for Extended Key Definition ZTIC has a value of 2.  The matching namespace declared in Segment Ids 21 and 22 is for namespace 131131/21, the base namespace.  Message Element 2312 for Extended Key Definition Code has a value of 2 which is used to represent the Extended Key Definition for language.  Message Element 2313 for Extended Key ZTIC has a value of 2 which again refers to namespace 131131/21, the base namespace.  Message Element 2314 for Extended Key Code has a value of 1 which in the context of this example refers to the English language.
ELEM 2    2    1    518  2    4                   Address Query--Paragraph #3
ELEM 2    2    1    519  2    5                   Segment Id 67 for Message Element 310, for Query, is the parent for the values of a Query.  This message has two Query nodes.  The first one is used to query the values of the Address Template.  The second one is used to retrieve the values of the Address.  Including the Query of the Address Template is useful because it retrieves the Meta Data of the address which provides meaningful descriptions for the Address data.  Segment Id 68 for Message Element 3100 contains a Query Id that is assigned by the client.  When the server returns a response, this same Id will be placed in a corresponding Message Element in the Query Response in Message Element 4100.  Segment Id 69 for Message Element 3101 is for the Object Template ZTIC for object being queried.  Because the object being queried is an Object Template this is the ZTIC for the Object Template of an Object Template.  This has a value of 2 representing namespace 131131/21, the base namespace.  Segment Id 70 for Message Element 3102 for Object Template Code has a value of 2.  This is the Code for the Object Template of an Object Template.  Segment Id 71 for Message Element 3103 for the Selection Mode has a value of 1 to indicate standard selection.  Segment Id 72 for Message Element 3104 has a value of + which can be ignored for this example.
ELEM 2    2    1    519  2    4                   Address Query--Paragraph #4
ELEM 2    2    1    520  2    5                   The next graphic completes the segments of the Request side of the message
ELEM 2    2    1    520  2    4                   Address Query--Paragraph #6
LINK 2    2    1    520  2    4    6    1    1    1026                          5179248000.000           
ELEM 2    2    1    521  2    5                   Segment Id 73 for Message Element 3110 for Selection Set and is the parent for Selection.  Segment Id 74 for Message Element 3111 is the parent for the first Selection.  Segments Ids 75, 76 and 77 for Message Elements 3112, 3113 and 3114 contain the Selection Group Number, Selection Group Number of parent and set operator.  This would be used for a more complex selection involving a hierarchy of selection groups and are not used for this example.
ELEM 2    2    1    521  2    4                   Address Query--Paragraph #5
ELEM 2    2    1    522  2    5                   Segment Id 78 for Message Element 3120 contains Object Selection Sets.  Segment Id 79 for Message Element 3121 is a child of Segment Id 78 and contains an Object Selection. Segment Ids 80 and 81 for Message Elements 3122 and 3123 are for hierarchy level and selection mode.  This selection does not have a multi-level hierarchy and the selection mode is 1, for standard.  Segment Id 82 for Message Element 3130 is for an object set used for selection.  This set will have only one member, the address template.  Segment Ids 83 through 86 for Message Elements 3140, 3150, 3160 and 3170 are parents elements for selection attributes that are not used in this message.  Segment Id 87 for Message Element 3131 is the parent for one object used in the selection.  Segment Ids 88 and 89 for Message Elements 3134 and 3135 contain the Object ZTIC and Object Code of the object being selected.  In this case the Object ZTIC has a value of 3 which corresponds to the namespace zinfinitree.com/address the namespace where the address application was developed. The Object Code 1 is the code for the Address Template Object in the Address Application.
ELEM 2    2    1    522  2    4                   Address Query--Paragraph #7
ELEM 2    2    1    523  2    5                   Segment Id 90 for Message Element 310 is the parent for the second Selection.  This Selection will be used to select the Address object.  It follows the same pattern that was used to select the Address Object Template.  Segment Id 91 for Message Element 3100 contains the Id of the Selection.  This Id will be included by the server it the response in Message Element 4100.  Segment Id 92 for Message Element 3101 contains the ZT Instance Code for the template for the selection of the object.  This has a value of 3 which corresponds to namespace zinfinitree.com/address, the namespace used for the address application.  Segment Id 93 for Message Element 3102 contains the code of the template used for the selection of the object.  This has a value of 1 for the Address Template defined in the Address Application.  Segment Id 94 for Message Element 3103 has the selection mode.  This has a value of 1 for standard selection.  Segment Id 95 for Message Element 3104 has a boolean value + for respond in summary only.  This attribute is not used in this message.  Segment Ids 96 through 112 for selection the Address object use the same pattern as Segment Ids 73 through 89 used to select the Address template object.  The only difference is in Segment Ids 111 and 112 for Message Elements 3134 and 3135 for the Object ZTIC and Code.  In this case the ZTIC is 12 which corresponds to namespace zt_abc.com/test1, the namespace where the address was created and the code 57, the code of the newly created address.
ELEM 2    2    1    523  2    4                   Address Query--Paragraph #8
ELEM 2    2    1    536  2    5                   The table below shows Data Elements for House Number and Street
ELEM 2    2    1    536  2    4                   Address Query Response--Paragraph #12
LINK 2    2    1    536  2    4    6    1    1    1034                          5179248000.000           
ELEM 2    2    1    524  2    5                   The table below shows the beginning of the Address query response.  These segments are added by the server.
ELEM 2    2    1    524  2    4                   Address Query Response--Introduction
LINK 2    2    1    524  2    4    6    1    1    1027                          5179248000.000           
ELEM 2    2    1    525  2    5                   Segment Id 113 for Message Element 4 is a child of the Root Message Element and is the parent for the Message Response.  Segment Id 114 for Message Element 43 is a child of Segment Id 113 and is a parent for Server Log System Messages.  Segment Id 115 for Message Element 41 is also a child of Segment Id 113 and is a parent for the Query Response.  Segment Id 116 for Message Element 410 is a child of Message Segment 115 and is the parent for Message Elements for the first Response node used to query the Address Template.  Segment Id 117 for Message Element 4100 is a child of Segment Id 116.  This segment holds the Id of the of Response node.  The value, ObjTmplQSet was assigned by the client and sent in Message Element 3100 in Segment Id 68.  The same value is returned by the server so that the client knows which Query node the Query Response Set is responding to.  Segment Id 118 for Message Element 4104 is a child of Segment Id 116 and hold the Response Type with a value of 1 for standard.  Segment Id 119 and 120 are not used for this message.
ELEM 2    2    1    525  2    4                   Address Query Response--Paragraph #1
ELEM 2    2    1    526  2    5                   Segment Id 121 for Message Element 4130 is the parent for the objects that will be included in the Response node for the Address Template.  Segment Id 122 for Message Element 4131 is a child of Segment Id 121.  This is the parent for the Message Elements of the an individual object, in this case the object for The Address Template.  Segment Id 123 for Message Element 4132 is a child of Segment Id 122.  It holds the Object Kind ZT Instance Code with a value of 2.  This refers to namespace 131131/21 the base namespace in Segment Ids 21 and 22.  Segment Id 124 for Message Element 4133 for the Object Kind Code has a value of 2, the Kind Code for Object Templates.  Segment id 125 for Message Element 4134 has the ZT Instance Code of the Object with a value of 3.  This corresponds to namespace zinfinitree.com/address in Segment Ids 24 and 25, the namespace used by the Address application.  Segment Id 126 for Message Element 4135 hold the Object Code with a value of 1, the Code of the Address Template within the Address application.  Segment Id 127 for Message Element 4137 with a value of 1 holds a numeric Id, assigned by the server to identify the object in a hierarchy of objects returned by the server. Segment Id 128 for Message Element 4138 holds the Id of the parent object.  Because the Address Template is at the top of the hierarchy, the parent has a value of 0.  Segment Id 129 for Message Element 4139 has the number of levels down in the hierarchy.  Because the Address Template object is at the top of the hierarchy the levels down is 0.
ELEM 2    2    1    526  2    4                   Address Query Response--Paragraph #2
ELEM 2    2    1    527  2    5                   Segment Id 130 for Message Element 4140 is the parent for Message Elements containing the Object Elements of an object.  Segment Id 131 for Message Element 4141 is a child of Segment Id 130 and is the parent for the Message Elements holding an individual Object Element.  Segment Id 132 for Message Element 4142 holds the ZT Instance Code of the Object Element with a value of 2.  This corresponds to namespace 131131/21 for the base namespace.  Segment Id 133 for Message Element 4143 hold the Code of the Object Element with a value of 2.  This the is the code for Object Template Description.  Segment Id 134 for Message Element 4144 hold the value of the Object Element, in the case the value is: Address (Base Template)
ELEM 2    2    1    527  2    4                   Address Query Response--Paragraph #3
ELEM 2    2    1    528  2    5                   Segment Id 135 for Message Element 4150 is the parent for Message Elements for Type Values of the Address Template.  Segment Id 136 for Message Element 4151 is the parent for an individual Type Value.  Segment Id 137 for Message Element 4152 is a child of Segment Id 136.  It contains the ZT Instance Code for the Type Definition of the Type Value and has a value of 2.  This corresponds to namespace 131131/21, the base namespace.  Segment 138 for Message Element 4153 is also a child of Segment Id 136.  It contains the Code for the Type Definition of the Type Value and has a value of 3.  Type Definition Code 3 is used to specify the Object Kind for a Object Template.  Segment Id 139 for Message Element 4154 is a child of Segment Id 136.  It contains the ZT Instance Code for the Type Value with a value of 3 which corresponds to namespace zinfinitree.com/address.  Segment Id 140 for Message Element 4155 contains the Type Value Code and has a value of 1.  Object Kind 1 within the zinfinitree.com/address namespace represents the Address Object Kind.
ELEM 2    2    1    528  2    4                   Address Query Response--Paragraph #4
ELEM 2    2    1    529  2    5                   Segment Id 141 for Message Element 4160 is the parent for links from the Address Template.  Segment Id 142 for Message Element 4161 is a child of Segment Id 141 and is the parent for an individual link.  Segment Id 143 for Message Element 4162 is a child of Segment Id 142.  This contains the ZT Instance Code of the Link Type and has a value of 2, the base namespace, 131131/21.  Segment Id 144 for Message Element 4163 for the Link Type Code and has a value of 1.  Link Type Code 1 represents to Link Type to link an Object Template to a Technical Profile.  Segment Id 145 for Message Element 4164 is for the ZT Instance Code of the Object Kind of the object being linked to.  This has a value of 2 which corresponds to the base namespace.  Segment Id 146 for Message Element 4165 contains the Kind Code for the object being linked to.  This has a value of 12 which is the Kind Code for Technical Profiles.  Segment Id 147 for Message Element 4166 for the ZT Instance Code of the object being linked to.  This has a value of 3 which corresponds to namespace zinfinitree.com/address.  Segment Id 148 for Message Element 4167 contains the code of the object being linked to.  This has a value of 1 which is the code for the Technical Profile used by the Address Template in the Address application.  Segment Id 149 for Message Element 41691 contains the status of the link.  This has a value of 1 for standard/active.  Segment Id 150 for Message Element 41692 contains the effective timestamp for the link.  Segment Id 151 for Message Element 41693 contains the value or strength of the link.  This has a value of 1000.
ELEM 2    2    1    529  2    4                   Address Query Response--Paragraph #5
ELEM 2    2    1    530  2    5                   The next table shows values returned by the server for the Address Technical Profile.  When an object is queried, in this case the Address Template, the server returns not only the object queried but also any objects that the queried object is linked to.  In this case the Address Template is linked to a Technical Profile.  In turn, any object that the child object is linked to is also returned.  This continues down the hierarchy until any object that was linked to is returned.  Each object that is returned follows the same pattern as the Address Template to include some combination of Object Element, Type Values and links.  Message Element 4137, 4138 and 4139 indicate relationships of the objects.  Message Element 4137 has a numeric id for the object and 4138 has the id of the parent.  In the graphic below, Message Element 4137 has a value of 2, the Id value of the Technical Profile.  Message Element 4138 has a value of 1, the Id of the parent of the Technical Profile which is the Address Template.  Message Element 4139 for levels down has a value of 1 because the Technical Profile is 1 level down the root level.
ELEM 2    2    1    530  2    4                   Address Query Response--Paragraph #6
LINK 2    2    1    530  2    4    6    1    1    1028                          5179248000.000           
ELEM 2    2    1    531  2    5                   The next table shows links from the Technical Profile to other Objects used by the Object Template
ELEM 2    2    1    531  2    4                   Address Query Response--Paragraph #7
LINK 2    2    1    531  2    4    6    1    1    1029                          5179248000.000           
ELEM 2    2    1    532  2    5                   The table below continues the links from the Technical Profile
ELEM 2    2    1    532  2    4                   Address Query Response--Paragraph #8
LINK 2    2    1    532  2    4    6    1    1    1030                          5179248000.000           
ELEM 2    2    1    533  2    5                   The table below continues links for the Technical Profile and includes an Object Element for house number.
ELEM 2    2    1    533  2    4                   Address Query Response--Paragraph #9
LINK 2    2    1    533  2    4    6    1    1    1031                          5179248000.000           
ELEM 2    2    1    534  2    5                   The table below shows the Object Elements for the Street and the City
ELEM 2    2    1    534  2    4                   Address Query Response--Paragraph #10
LINK 2    2    1    534  2    4    6    1    1    1032                          5179248000.000           
ELEM 2    2    1    535  2    5                   The table below shows the Object Elements for State/Province and Postal Code
ELEM 2    2    1    535  2    4                   Address Query Response--Paragraph #11
LINK 2    2    1    535  2    4    6    1    1    1033                          5179248000.000           
ELEM 2    2    1    537  2    5                   The table below show data element for city
ELEM 2    2    1    537  2    4                   Address Query Response--Paragraph #13
LINK 2    2    1    537  2    4    6    1    1    1035                          5179248000.000           
ELEM 2    2    1    538  2    5                   The table below shows the Data Elements for State/Province and Postal Code
ELEM 2    2    1    538  2    4                   Address Query Response--Paragraph #14
LINK 2    2    1    538  2    4    6    1    1    1036                          5179248000.000           
ELEM 2    2    1    539  2    5                   The table below shows the values from the Address object being queried.
ELEM 2    2    1    539  2    4                   Address Query Response--Paragraph #15
LINK 2    2    1    539  2    4    6    1    1    1037                          5179248000.000           
ELEM 5    3    1    3002 5    6                   Description
ELEM 5    3    1    3002 5    7                   Description
TYPE 5    3    1    3002 5    3    5    2              
TYPE 5    3    1    3002 5    6    3    1              
ELEM 5    2    1    2001 5    4                   Object Kinds in base namespace
ELEM 5    2    1    2001 5    5                   Base Object Kinds
ELEM 5    3    1    3001 5    6                   Code description
ELEM 5    3    1    3001 5    7                   Code
TYPE 5    3    1    3001 5    3    5    9              
TYPE 5    3    1    3001 5    6    3    1              
TYPE 5    3    1    3001 5    10   5    2              
ELEM 5    4    1    4001 5    8                   RowGenByObjKindAndNS
ELEM 5    4    1    4001 5    9                   RowGenByObjKindAndNS
TYPE 5    4    1    4001 5    9    1    13003          
TYPE 5    4    1    4001 5    4    5    3              
ELEM 5    1    1    1001 5    3                   2
ELEM 5    1    1    1001 5    2                   Base Object Kinds
ELEM 5    1    1    1001 5    1                   Object Kinds in base namespace
LINK 5    1    1    1001 5    2    5    3    1    3002                          5179248000.000      8000 
LINK 5    1    1    1001 5    1    5    2    1    2001                          5179248000.000           
LINK 5    1    1    1001 5    2    5    3    1    3001                          5179248000.000      9000 
LINK 5    1    1    1001 5    3    5    4    1    4001                          5179248000.000           
ELEM 5    3    1    3021 5    6                   Description
ELEM 5    3    1    3021 5    7                   Description
TYPE 5    3    1    3021 5    3    5    2              
TYPE 5    3    1    3021 5    6    3    9              
ELEM 5    2    1    2020 5    4                   Type Definitions in Base Namespace
ELEM 5    2    1    2020 5    5                   Type Definitions in Base Namespace
ELEM 5    3    1    3020 5    6                   Code
ELEM 5    3    1    3020 5    7                   Code
TYPE 5    3    1    3020 5    3    5    9              
TYPE 5    3    1    3020 5    10   5    2              
ELEM 5    4    1    4020 5    8                   RowGenSetOfTypeDefinitions
ELEM 5    4    1    4020 5    9                   RowGenSetOfTypeDefinitions
TYPE 5    4    1    4020 5    4    5    3              
TYPE 5    4    1    4020 5    9    1    13020          
ELEM 5    1    1    1020 5    1                   Type Definitions in Base Namespace
ELEM 5    1    1    1020 5    3                   2
ELEM 5    1    1    1020 5    2                   Type Definitions in Base Namespace
LINK 5    1    1    1020 5    2    5    3    1    3021                          5179248000.000      8000 
LINK 5    1    1    1020 5    1    5    2    1    2020                          5179248000.000           
LINK 5    1    1    1020 5    2    5    3    1    3020                          5179248000.000      9000 
LINK 5    1    1    1020 5    3    5    4    1    4020                          5179248000.000           
ELEM 5    3    1    3022 5    6                   Code
ELEM 5    3    1    3022 5    7                   Code
TYPE 5    3    1    3022 5    3    5    9              
TYPE 5    3    1    3022 5    10   5    2              
ELEM 5    3    1    3023 5    6                   Description
ELEM 5    3    1    3023 5    7                   Description
TYPE 5    3    1    3023 5    3    5    2              
TYPE 5    3    1    3023 5    6    3    3              
ELEM 5    2    1    2021 5    5                   Object Elements in Base Namespace
ELEM 5    2    1    2021 5    4                   Object Elements in Base Namespace
ELEM 5    4    1    4021 5    8                   RowGenSetOfObjectElements
ELEM 5    4    1    4021 5    9                   RowGenSetOfObjectElements
TYPE 5    4    1    4021 5    4    5    3              
TYPE 5    4    1    4021 5    9    1    13021          
ELEM 5    1    1    1021 5    1                   Object Elements in Base Namespace
ELEM 5    1    1    1021 5    3                   2
ELEM 5    1    1    1021 5    2                   Object Elements  in Base Namespace
LINK 5    1    1    1021 5    2    5    3    1    3022                          5179248000.000      9000 
LINK 5    1    1    1021 5    2    5    3    1    3023                          5179248000.000      8000 
LINK 5    1    1    1021 5    1    5    2    1    2021                          5179248000.000           
LINK 5    1    1    1021 5    3    5    4    1    4021                          5179248000.000           
ELEM 5    3    1    3025 5    7                   Description
ELEM 5    3    1    3025 5    6                   Description
TYPE 5    3    1    3025 5    6    3    10             
TYPE 5    3    1    3025 5    3    5    2              
ELEM 5    3    1    3024 5    7                   Code
ELEM 5    3    1    3024 5    6                   Code
TYPE 5    3    1    3024 5    10   5    2              
TYPE 5    3    1    3024 5    3    5    9              
ELEM 5    4    1    4024 5    9                   RowGenSetOfLinkTypes
ELEM 5    4    1    4024 5    8                   RowGenSetOfLinkTypes
TYPE 5    4    1    4024 5    9    1    13031          
TYPE 5    4    1    4024 5    4    5    3              
ELEM 5    2    1    2023 5    5                   List of Link Types in Base Namespace
ELEM 5    2    1    2023 5    4                   List of Link Types in Base Namespace
ELEM 5    1    1    1023 5    3                   2
ELEM 5    1    1    1023 5    2                   List of Link Types in Base Namespace
ELEM 5    1    1    1023 5    1                   List of Link Types in Base Namespace
LINK 5    1    1    1023 5    2    5    3    1    3025                          5179248000.000      8000 
LINK 5    1    1    1023 5    2    5    3    1    3024                          5179248000.000      9000 
LINK 5    1    1    1023 5    3    5    4    1    4024                          5179248000.000           
LINK 5    1    1    1023 5    1    5    2    1    2023                          5179248000.000           
ELEM 5    1    1    1025 5    3                   2
ELEM 5    1    1    1025 5    1                   List of Base Table Elements for Objects
ELEM 5    1    1    1025 5    2                   List of Base Table Elements for Objects
LINK 5    1    1    1025 5    2    5    3    1    3028                          5179248000.000      8000 
LINK 5    1    1    1025 5    3    5    4    1    4026                          5179248000.000           
LINK 5    1    1    1025 5    2    5    3    1    3027                          5179248000.000      9000 
LINK 5    1    1    1025 5    1    5    2    1    2025                          5179248000.000           
ELEM 5    1    1    1005 5    1                   List of Base Table Elements for Objects
ELEM 5    1    1    1005 5    2                   List of Base Table Elements for Objects
ELEM 5    1    1    1005 5    3                   2
LINK 5    1    1    1005 5    1    5    2    1    2008                          5179248000.000           
LINK 5    1    1    1005 5    2    5    3    1    3009                          5179248000.000           
LINK 5    1    1    1005 5    2    5    3    1    3008                          5179248000.000           
LINK 5    1    1    1005 5    3    5    4    1    4008                          5179248000.000           
ELEM 6    1    1    1050 6    1                   HTML list of Base Object Element values
ELEM 6    1    1    1050 6    2                   HTML List of Base Object Element values
ELEM 6    1    1    1050 6    3                   Base Object Element Values
ELEM 6    1    1    1050 6    4                   
ELEM 6    1    1    1050 6    5                   
LINK 6    1    1    1050 6    1    3    39   1    39050                         5179248000.000           
ELEM 6    1    1    1051 6    1                   HTML list of Base Type Values
ELEM 6    1    1    1051 6    2                   HTML list of Base Type Values
ELEM 6    1    1    1051 6    3                   HTML list of Base Type Values
ELEM 6    1    1    1051 6    4                   
ELEM 6    1    1    1051 6    5                   
LINK 6    1    1    1051 6    1    3    39   1    39051                         5179248000.000           
ELEM 6    1    1    1052 6    1                   HTML list of Base Links
ELEM 6    1    1    1052 6    2                   HTML list of Base Links
ELEM 6    1    1    1052 6    3                   HTML list of Base Links
ELEM 6    1    1    1052 6    4                   
ELEM 6    1    1    1052 6    5                   
LINK 6    1    1    1052 6    1    3    39   1    39052                         5179248000.000           
ELEM 3    39   1    390003    39                  
ELEM 3    39   1    390003    210                 
ELEM 3    39   1    390003    211                 
ELEM 3    39   1    390003    212                 /doc1/overview_graphic1.jpg
ELEM 3    39   1    390003    213                 
ELEM 2    2    1    207  2    4                   Design Goal #1
ELEM 2    2    1    207  2    5                   It should be possible to build applications with minimal programming using generically defined objects.
ELEM 2    2    1    208  2    5                   Applications should be multi-language (human) without having to do any special coding.
ELEM 2    2    1    208  2    4                   Design Goal #2
ELEM 2    2    1    209  2    5                   It should be possible to extend ZT Server applications and combine them with other ZT Server applications with minimal or no coding.
ELEM 2    2    1    209  2    4                   Design Goal #3
ELEM 2    2    1    213  2    4                   Design Goal #4
ELEM 2    2    1    213  2    5                   Applications should have access to a complete change history without coding.  Objects that are linked to older versions of other objects should have access to the older values even if a new version of the object being linked to has changed.
ELEM 2    2    1    214  2    5                   It should be easy for users to share data and applications with each other.
ELEM 2    2    1    214  2    4                   Design Goal #5
ELEM 2    2    1    215  2    5                   It should be easy to identify the source of any objects in the system.  It should also be easy to remove unwanted objects that were previously imported or created based on source or other criteria.
ELEM 2    2    1    215  2    4                   Design Goal #6
ELEM 2    2    1    216  2    4                   Design Goal #7
ELEM 2    2    1    216  2    5                   The design should be understandable and accessible.  A person should be able to move from being an application user to application configurator to application developer to client or server developer in a natural progression.
ELEM 2    2    1    217  2    5                   It should be possible to implement the design with a reasonable amount of effort using industry standard protocols and products that are available in open source implementations.
ELEM 2    2    1    217  2    4                   Design Goal #8
ELEM 2    2    1    568  2    4                   
ELEM 2    2    1    568  2    5                   The document should be translatable from English to other languages without using characters from the English alphabet.
ELEM 2    2    1    569  2    4                   doc goal 2
ELEM 2    2    1    569  2    5                   It should be possible to implement the design with a reasonable amount of effort using industry standard protocols and products that are available in open source implementations
ELEM 5    2    1    2008 5    5                   Base Table Elements
ELEM 5    2    1    2008 5    4                   Base Table Elements
ELEM 5    3    1    3009 5    7                   Description
ELEM 5    3    1    3009 5    6                   Description
TYPE 5    3    1    3009 5    6    3    4              
TYPE 5    3    1    3009 5    3    5    2              
ELEM 5    3    1    3008 5    6                   Code
ELEM 5    3    1    3008 5    7                   Code
TYPE 5    3    1    3008 5    3    5    9              
TYPE 5    3    1    3008 5    10   5    2              
ELEM 5    4    1    4008 5    8                   RowGenSetOfTableElements
ELEM 5    4    1    4008 5    9                   RowGenSetOfTableElements
TYPE 5    4    1    4008 5    4    5    3              
TYPE 5    4    1    4008 5    9    1    13010          
ELEM 3    39   1    390013    213                 
ELEM 3    39   1    390013    212                 /doc1/versioning1.jpg
ELEM 3    39   1    390013    211                 
ELEM 3    39   1    390013    210                 
ELEM 3    39   1    390013    39                  
ELEM 3    39   1    390023    213                 
ELEM 3    39   1    390023    212                 /doc1/versioning_master_data_copied_in.jpg
ELEM 3    39   1    390023    211                 
ELEM 3    39   1    390023    210                 
ELEM 3    39   1    390023    39                  
ELEM 3    39   1    390033    213                 
ELEM 3    39   1    390033    212                 /doc1/versioning_sales_order_with_timestamps.jpg
ELEM 3    39   1    390033    211                 
ELEM 3    39   1    390033    210                 
ELEM 3    39   1    390033    39                  
ELEM 3    39   1    390053    39                  
ELEM 3    39   1    390053    210                 
ELEM 3    39   1    390053    211                 
ELEM 3    39   1    390053    212                 /doc1/zt_instance_dev2.jpg
ELEM 3    39   1    390053    213                 
ELEM 3    39   1    390063    39                  
ELEM 3    39   1    390063    210                 
ELEM 3    39   1    390063    211                 
ELEM 3    39   1    390063    212                 /doc1/zt_instance_dev3.jpg
ELEM 3    39   1    390063    213                 
ELEM 3    39   1    390043    213                 
ELEM 3    39   1    390043    212                 /doc1/zt_instance_dev1.jpg
ELEM 3    39   1    390043    211                 
ELEM 3    39   1    390043    210                 
ELEM 3    39   1    390043    39                  
ELEM 3    39   1    390013    213                 
ELEM 3    39   1    390013    212                 /doc1/versioning1.jpg
ELEM 3    39   1    390013    211                 
ELEM 3    39   1    390013    210                 
ELEM 3    39   1    390013    39                  
ELEM 3    39   1    390023    213                 
ELEM 3    39   1    390023    212                 /doc1/versioning_master_data_copied_in.jpg
ELEM 3    39   1    390023    211                 
ELEM 3    39   1    390023    210                 
ELEM 3    39   1    390023    39                  
ELEM 3    39   1    390033    213                 
ELEM 3    39   1    390033    212                 /doc1/versioning_sales_order_with_timestamps.jpg
ELEM 3    39   1    390033    211                 
ELEM 3    39   1    390033    210                 
ELEM 3    39   1    390033    39                  
ELEM 3    39   1    390053    39                  
ELEM 3    39   1    390053    210                 
ELEM 3    39   1    390053    211                 
ELEM 3    39   1    390053    212                 /doc1/zt_instance_dev2.jpg
ELEM 3    39   1    390053    213                 
ELEM 3    39   1    390063    39                  
ELEM 3    39   1    390063    210                 
ELEM 3    39   1    390063    211                 
ELEM 3    39   1    390063    212                 /doc1/zt_instance_dev3.jpg
ELEM 3    39   1    390063    213                 
ELEM 3    39   1    390043    213                 
ELEM 3    39   1    390043    212                 /doc1/zt_instance_dev1.jpg
ELEM 3    39   1    390043    211                 
ELEM 3    39   1    390043    210                 
ELEM 3    39   1    390043    39                  
ELEM 3    39   1    390093    39                  
ELEM 3    39   1    390093    210                 communication_message_structure
ELEM 3    39   1    390093    211                 
ELEM 3    39   1    390093    212                 /doc1/communication_message_structure.jpg
ELEM 3    39   1    390093    213                 
ELEM 6    1    1    1038 6    2                   Address data collection by client
ELEM 6    1    1    1038 6    5                   400
ELEM 6    1    1    1038 6    4                   500
ELEM 6    1    1    1038 6    3                   Address data collection by client
ELEM 6    1    1    1038 6    1                   Address data collection by client
LINK 6    1    1    1038 6    1    3    39   1    39038                         5179248000.000           
ELEM 6    1    1    1009 6    1                   Address Create Example-graphic 2
ELEM 6    1    1    1009 6    2                   address create example-graphic 2
ELEM 6    1    1    1009 6    3                   Address Create-Graphic 2
ELEM 6    1    1    1009 6    4                   700
ELEM 6    1    1    1009 6    5                   900
LINK 6    1    1    1009 6    1    3    39   1    39008                         5179248000.000           
ELEM 6    1    1    1008 6    1                   Create Address Message #1
ELEM 6    1    1    1008 6    2                   Create Address Message #1
ELEM 6    1    1    1008 6    3                   Create Address Message
ELEM 6    1    1    1008 6    4                   800
ELEM 6    1    1    1008 6    5                   1100
LINK 6    1    1    1008 6    1    3    39   1    39007                         5179248000.000           
ELEM 6    1    1    1020 6    5                   1100
ELEM 6    1    1    1020 6    4                   800
ELEM 6    1    1    1020 6    3                   Address Create-Graphic 3
ELEM 6    1    1    1020 6    2                   Address Create Example-graphic 3
ELEM 6    1    1    1020 6    1                   Address Create Example-graphic 3
LINK 6    1    1    1020 6    1    3    39   1    39020                         5179248000.000           
ELEM 6    1    1    1021 6    5                   700
ELEM 6    1    1    1021 6    4                   800
ELEM 6    1    1    1021 6    3                   Address Create-Graphic 4
ELEM 6    1    1    1021 6    2                   Address Create Example-graphic 4
ELEM 6    1    1    1021 6    1                   Address Create Example-graphic 4
LINK 6    1    1    1021 6    1    3    39   1    39021                         5179248000.000           
ELEM 6    1    1    1022 6    5                   400
ELEM 6    1    1    1022 6    3                   Address Create-Graphic 5 db update
ELEM 6    1    1    1022 6    4                   1200
ELEM 6    1    1    1022 6    2                   Address Create-Graphic 5 db update
ELEM 6    1    1    1022 6    1                   Address Create-Graphic 5 db update
LINK 6    1    1    1022 6    1    3    39   1    39022                         5179248000.000           
ELEM 6    1    1    1023 6    5                   400
ELEM 6    1    1    1023 6    3                   ZTIC table on server
ELEM 6    1    1    1023 6    4                   800
ELEM 6    1    1    1023 6    2                   ZTIC table on server
ELEM 6    1    1    1023 6    1                   ZTIC table on server
LINK 6    1    1    1023 6    1    3    39   1    39023                         5179248000.000           
ELEM 6    1    1    1024 6    5                   1100
ELEM 6    1    1    1024 6    4                   800
ELEM 6    1    1    1024 6    3                   Address Query Message Image #1
ELEM 6    1    1    1024 6    2                   Address Query Message Image #1
ELEM 6    1    1    1024 6    1                   Address Query Message Image #1
LINK 6    1    1    1024 6    1    3    39   1    39024                         5179248000.000           
ELEM 6    1    1    1025 6    5                   1100
ELEM 6    1    1    1025 6    4                   800
ELEM 6    1    1    1025 6    3                   Address Query Message Image #2
ELEM 6    1    1    1025 6    2                   Address Query Message Image #2
ELEM 6    1    1    1025 6    1                   Address Query Message Image #2
LINK 6    1    1    1025 6    1    3    39   1    39025                         5179248000.000           
ELEM 6    1    1    1026 6    4                   800
ELEM 6    1    1    1026 6    5                   1100
ELEM 6    1    1    1026 6    3                   Address Query Message Image #3
ELEM 6    1    1    1026 6    2                   Address Query Message Image #3
ELEM 6    1    1    1026 6    1                   Address Query Message Image #3
LINK 6    1    1    1026 6    1    3    39   1    39026                         5179248000.000           
ELEM 6    1    1    1034 6    4                   800
ELEM 6    1    1    1034 6    5                   1100
ELEM 6    1    1    1034 6    3                   DE for House Number and Street
ELEM 6    1    1    1034 6    2                   Address Query Response Message--Image #8--Data Elements for house number and  street
ELEM 6    1    1    1034 6    1                   Address Query Response Message--Image #8--DE for house number and  street
LINK 6    1    1    1034 6    1    3    39   1    39034                         5179248000.000           
ELEM 6    1    1    1027 6    5                   1100
ELEM 6    1    1    1027 6    4                   800
ELEM 6    1    1    1027 6    3                   Address Query Response Message--Image #1
ELEM 6    1    1    1027 6    2                   Address Query Response Message--Image #1
ELEM 6    1    1    1027 6    1                   Address Query Response Message--Image #1
LINK 6    1    1    1027 6    1    3    39   1    39027                         5179248000.000           
ELEM 6    1    1    1028 6    5                   1100
ELEM 6    1    1    1028 6    4                   800
ELEM 6    1    1    1028 6    3                   Address Query Response Message--Image #2
ELEM 6    1    1    1028 6    2                   Address Query Response Message--Image #2 Technical Profile
ELEM 6    1    1    1028 6    1                   Address Query Response Message--Image #2
LINK 6    1    1    1028 6    1    3    39   1    39028                         5179248000.000           
ELEM 6    1    1    1029 6    4                   800
ELEM 6    1    1    1029 6    5                   1100
ELEM 6    1    1    1029 6    3                   Address Query Response Message--Image #3
ELEM 6    1    1    1029 6    2                   Address Query Response Message--Image #3--links from tech profile
ELEM 6    1    1    1029 6    1                   Address Query Response Message--Image #3--links
LINK 6    1    1    1029 6    1    3    39   1    39029                         5179248000.000           
ELEM 6    1    1    1030 6    5                   1100
ELEM 6    1    1    1030 6    4                   800
ELEM 6    1    1    1030 6    3                   Address Query Response Message--Image #4
ELEM 6    1    1    1030 6    2                   Address Query Response Message--Image #4--continue links from tech profile
ELEM 6    1    1    1030 6    1                   Address Query Response Message--Image #4--links continued
LINK 6    1    1    1030 6    1    3    39   1    39030                         5179248000.000           
ELEM 6    1    1    1031 6    5                   1100
ELEM 6    1    1    1031 6    4                   800
ELEM 6    1    1    1031 6    3                   Address Query Response Message--Image #5--links and house number
ELEM 6    1    1    1031 6    2                   Address Query Response Message--Image #5--links and house number
ELEM 6    1    1    1031 6    1                   Address Query Response Message--Image #5--links and house number
LINK 6    1    1    1031 6    1    3    39   1    39031                         5179248000.000           
ELEM 6    1    1    1032 6    4                   800
ELEM 6    1    1    1032 6    5                   1100
ELEM 6    1    1    1032 6    3                   OE Street and City
ELEM 6    1    1    1032 6    2                   Address Query Response Message--Image #6--Object Elements for Street and City
ELEM 6    1    1    1032 6    1                   Address Query Response Message--Image #6--OE for street and city
LINK 6    1    1    1032 6    1    3    39   1    39032                         5179248000.000           
ELEM 6    1    1    1033 6    4                   800
ELEM 6    1    1    1033 6    5                   1100
ELEM 6    1    1    1033 6    3                   OE State/Province and Postal Code
ELEM 6    1    1    1033 6    2                   Address Query Response Message--Image #7--Object Elements for state/province and postal code
ELEM 6    1    1    1033 6    1                   Address Query Response Message--Image #7--OE for state/province and postal code
LINK 6    1    1    1033 6    1    3    39   1    39033                         5179248000.000           
ELEM 6    1    1    1035 6    5                   1100
ELEM 6    1    1    1035 6    4                   800
ELEM 6    1    1    1035 6    3                   DE -- City
ELEM 6    1    1    1035 6    2                   Address Query Response Message--Image #9--Data Element for city
ELEM 6    1    1    1035 6    1                   Address Query Response Message--Image #9--DE for city
LINK 6    1    1    1035 6    1    3    39   1    39035                         5179248000.000           
ELEM 6    1    1    1036 6    4                   800
ELEM 6    1    1    1036 6    5                   1100
ELEM 6    1    1    1036 6    3                   DE State/Province and Postal Code
ELEM 6    1    1    1036 6    2                   Address Query Response Message--Image #10--Data Elements for state and postal code
ELEM 6    1    1    1036 6    1                   Address Query Response Message--Image #10--DE for state and postal code
LINK 6    1    1    1036 6    1    3    39   1    39036                         5179248000.000           
ELEM 6    1    1    1037 6    4                   800
ELEM 6    1    1    1037 6    5                   1100
ELEM 6    1    1    1037 6    3                   Address Query Response Message--Image #11--values for address queried
ELEM 6    1    1    1037 6    2                   Address Query Response Message--Image #11--values for address queried
ELEM 6    1    1    1037 6    1                   Address Query Response Message--Image #11--values for address queried
LINK 6    1    1    1037 6    1    3    39   1    39037                         5179248000.000           
ELEM 5    3    1    3002 5    6                   Description
ELEM 5    3    1    3002 5    7                   Description
TYPE 5    3    1    3002 5    3    5    2              
TYPE 5    3    1    3002 5    6    3    1              
ELEM 5    2    1    2001 5    4                   Object Kinds in base namespace
ELEM 5    2    1    2001 5    5                   Base Object Kinds
ELEM 5    3    1    3001 5    6                   Code description
ELEM 5    3    1    3001 5    7                   Code
TYPE 5    3    1    3001 5    3    5    9              
TYPE 5    3    1    3001 5    6    3    1              
TYPE 5    3    1    3001 5    10   5    2              
ELEM 5    4    1    4001 5    8                   RowGenByObjKindAndNS
ELEM 5    4    1    4001 5    9                   RowGenByObjKindAndNS
TYPE 5    4    1    4001 5    9    1    13003          
TYPE 5    4    1    4001 5    4    5    3              
ELEM 5    3    1    3021 5    6                   Description
ELEM 5    3    1    3021 5    7                   Description
TYPE 5    3    1    3021 5    3    5    2              
TYPE 5    3    1    3021 5    6    3    9              
ELEM 5    2    1    2020 5    4                   Type Definitions in Base Namespace
ELEM 5    2    1    2020 5    5                   Type Definitions in Base Namespace
ELEM 5    3    1    3020 5    6                   Code
ELEM 5    3    1    3020 5    7                   Code
TYPE 5    3    1    3020 5    3    5    9              
TYPE 5    3    1    3020 5    10   5    2              
ELEM 5    4    1    4020 5    8                   RowGenSetOfTypeDefinitions
ELEM 5    4    1    4020 5    9                   RowGenSetOfTypeDefinitions
TYPE 5    4    1    4020 5    4    5    3              
TYPE 5    4    1    4020 5    9    1    13020          
ELEM 5    3    1    3022 5    6                   Code
ELEM 5    3    1    3022 5    7                   Code
TYPE 5    3    1    3022 5    3    5    9              
TYPE 5    3    1    3022 5    10   5    2              
ELEM 5    3    1    3023 5    6                   Description
ELEM 5    3    1    3023 5    7                   Description
TYPE 5    3    1    3023 5    3    5    2              
TYPE 5    3    1    3023 5    6    3    3              
ELEM 5    2    1    2021 5    5                   Object Elements in Base Namespace
ELEM 5    2    1    2021 5    4                   Object Elements in Base Namespace
ELEM 5    4    1    4021 5    8                   RowGenSetOfObjectElements
ELEM 5    4    1    4021 5    9                   RowGenSetOfObjectElements
TYPE 5    4    1    4021 5    4    5    3              
TYPE 5    4    1    4021 5    9    1    13021          
ELEM 5    3    1    3025 5    7                   Description
ELEM 5    3    1    3025 5    6                   Description
TYPE 5    3    1    3025 5    6    3    10             
TYPE 5    3    1    3025 5    3    5    2              
ELEM 5    3    1    3024 5    7                   Code
ELEM 5    3    1    3024 5    6                   Code
TYPE 5    3    1    3024 5    10   5    2              
TYPE 5    3    1    3024 5    3    5    9              
ELEM 5    4    1    4024 5    9                   RowGenSetOfLinkTypes
ELEM 5    4    1    4024 5    8                   RowGenSetOfLinkTypes
TYPE 5    4    1    4024 5    9    1    13031          
TYPE 5    4    1    4024 5    4    5    3              
ELEM 5    2    1    2023 5    5                   List of Link Types in Base Namespace
ELEM 5    2    1    2023 5    4                   List of Link Types in Base Namespace
ELEM 5    3    1    3028 5    7                   Description
ELEM 5    3    1    3028 5    6                   Description
TYPE 5    3    1    3028 5    6    3    4              
TYPE 5    3    1    3028 5    3    5    2              
ELEM 5    4    1    4026 5    9                   RowGenSetOfTableElements
ELEM 5    4    1    4026 5    8                   RowGenSetOfTableElements
TYPE 5    4    1    4026 5    9    1    13010          
TYPE 5    4    1    4026 5    4    5    3              
ELEM 5    3    1    3027 5    7                   Code
ELEM 5    3    1    3027 5    6                   Code
TYPE 5    3    1    3027 5    10   5    2              
TYPE 5    3    1    3027 5    3    5    9              
ELEM 5    2    1    2025 5    5                   Base Table Elements
ELEM 5    2    1    2025 5    4                   Base Table Elements
ELEM 5    2    1    2008 5    5                   Base Table Elements
ELEM 5    2    1    2008 5    4                   Base Table Elements
ELEM 5    3    1    3009 5    7                   Description
ELEM 5    3    1    3009 5    6                   Description
TYPE 5    3    1    3009 5    6    3    4              
TYPE 5    3    1    3009 5    3    5    2              
ELEM 5    3    1    3008 5    6                   Code
ELEM 5    3    1    3008 5    7                   Code
TYPE 5    3    1    3008 5    3    5    9              
TYPE 5    3    1    3008 5    10   5    2              
ELEM 5    4    1    4008 5    8                   RowGenSetOfTableElements
ELEM 5    4    1    4008 5    9                   RowGenSetOfTableElements
TYPE 5    4    1    4008 5    4    5    3              
TYPE 5    4    1    4008 5    9    1    13010          
ELEM 3    39   1    390503    39                  Base Object Element Values list
ELEM 3    39   1    390503    210                 /doc1/html/base_object_values_oe.html
ELEM 3    39   1    390503    211                 -
ELEM 3    39   1    390503    212                 /doc1/html/base_object_values_oe.html
ELEM 3    39   1    390503    213                 -
ELEM 3    39   1    390513    39                  
ELEM 3    39   1    390513    210                 /doc1/html/base_object_values_tval.html
ELEM 3    39   1    390513    211                 -
ELEM 3    39   1    390513    212                 /doc1/html/base_object_values_tval.html
ELEM 3    39   1    390513    213                 -
ELEM 3    39   1    390523    39                  
ELEM 3    39   1    390523    210                 /doc1/html/base_object_values_link.html
ELEM 3    39   1    390523    211                 -
ELEM 3    39   1    390523    212                 /doc1/html/base_object_values_link.html
ELEM 3    39   1    390523    213                 -
ELEM 3    39   1    390383    213                 
ELEM 3    39   1    390383    212                 /doc1/address_create_example_data_collection.jpg
ELEM 3    39   1    390383    210                 address_create_example_data_collection
ELEM 3    39   1    390383    211                 
ELEM 3    39   1    390383    39                  
ELEM 3    39   1    390083    39                  
ELEM 3    39   1    390083    210                 address_create_example2
ELEM 3    39   1    390083    211                 
ELEM 3    39   1    390083    212                 /doc1/address_create_example_img2.jpg
ELEM 3    39   1    390083    213                 
ELEM 3    39   1    390073    39                  
ELEM 3    39   1    390073    210                 address_create_example1
ELEM 3    39   1    390073    211                 
ELEM 3    39   1    390073    212                 /doc1/address_create_example_img1.jpg
ELEM 3    39   1    390073    213                 
ELEM 3    39   1    390203    213                 
ELEM 3    39   1    390203    212                 /doc1/address_create_example_img3.jpg
ELEM 3    39   1    390203    211                 
ELEM 3    39   1    390203    210                 address_create_example3
ELEM 3    39   1    390203    39                  
ELEM 3    39   1    390213    212                 /doc1/address_create_example_img4.jpg
ELEM 3    39   1    390213    213                 
ELEM 3    39   1    390213    211                 
ELEM 3    39   1    390213    210                 address_create_example4
ELEM 3    39   1    390213    39                  
ELEM 3    39   1    390223    212                 /doc1/address_create_example_db_update_img5.jpg
ELEM 3    39   1    390223    213                 
ELEM 3    39   1    390223    211                 
ELEM 3    39   1    390223    210                 address_create_example_db_update_img5.jpg
ELEM 3    39   1    390223    39                  
ELEM 3    39   1    390233    212                 /doc1/address_create_example_ztic_tab_img6.jpg
ELEM 3    39   1    390233    213                 
ELEM 3    39   1    390233    211                 
ELEM 3    39   1    390233    210                 address_create_example_ztic_tab_img6.jpg
ELEM 3    39   1    390233    39                  
ELEM 3    39   1    390243    213                 x
ELEM 3    39   1    390243    212                 /doc1/address_query_example_img1.jpg
ELEM 3    39   1    390243    211                 
ELEM 3    39   1    390243    210                 address_query_example_img1.jpg
ELEM 3    39   1    390243    39                  
ELEM 3    39   1    390253    212                 /doc1/address_query_example_img2.jpg
ELEM 3    39   1    390253    213                 
ELEM 3    39   1    390253    211                 
ELEM 3    39   1    390253    210                 address_query_example_img2.jpg
ELEM 3    39   1    390253    39                  
ELEM 3    39   1    390263    213                 
ELEM 3    39   1    390263    212                 /doc1/address_query_example_img3.jpg
ELEM 3    39   1    390263    211                 
ELEM 3    39   1    390263    210                 address_query_example_img3.jpg
ELEM 3    39   1    390263    39                  
ELEM 3    39   1    390343    213                 
ELEM 3    39   1    390343    212                 /doc1/address_query_response_example_img8.jpg
ELEM 3    39   1    390343    211                 
ELEM 3    39   1    390343    210                 /doc1/address_query_response_example_img8.jpg
ELEM 3    39   1    390343    39                  
ELEM 3    39   1    390273    212                 /doc1/address_query_response_example_img1.jpg
ELEM 3    39   1    390273    213                 
ELEM 3    39   1    390273    211                 
ELEM 3    39   1    390273    210                 address_query_response_example_img1.jpg
ELEM 3    39   1    390273    39                  
ELEM 3    39   1    390283    211                 
ELEM 3    39   1    390283    213                 
ELEM 3    39   1    390283    212                 /doc1/address_query_response_example_img2.jpg
ELEM 3    39   1    390283    210                 address_query_response_example_img2.jpg
ELEM 3    39   1    390283    39                  
ELEM 3    39   1    390293    212                 /doc1/address_query_response_example_img3.jpg
ELEM 3    39   1    390293    213                 
ELEM 3    39   1    390293    211                 
ELEM 3    39   1    390293    210                 response_example_img3.jpg
ELEM 3    39   1    390293    39                  
ELEM 3    39   1    390303    213                 
ELEM 3    39   1    390303    212                 /doc1/address_query_response_example_img4.jpg
ELEM 3    39   1    390303    211                 
ELEM 3    39   1    390303    210                 response_example_img4.jpg
ELEM 3    39   1    390303    39                  
ELEM 3    39   1    390313    213                 
ELEM 3    39   1    390313    212                 /doc1/address_query_response_example_img5.jpg
ELEM 3    39   1    390313    211                 
ELEM 3    39   1    390313    210                 /doc1/address_query_response_example_img5.jpg
ELEM 3    39   1    390313    39                  
ELEM 3    39   1    390323    213                 
ELEM 3    39   1    390323    212                 /doc1/address_query_response_example_img6.jpg
ELEM 3    39   1    390323    211                 
ELEM 3    39   1    390323    210                 /doc1/address_query_response_example_img6.jpg
ELEM 3    39   1    390323    39                  
ELEM 3    39   1    390333    212                 /doc1/address_query_response_example_img7.jpg
ELEM 3    39   1    390333    213                 
ELEM 3    39   1    390333    211                 
ELEM 3    39   1    390333    210                 /doc1/address_query_response_example_img7.jpg
ELEM 3    39   1    390333    39                  
ELEM 3    39   1    390353    212                 /doc1/address_query_response_example_img9.jpg
ELEM 3    39   1    390353    213                 
ELEM 3    39   1    390353    211                 
ELEM 3    39   1    390353    210                 /doc1/address_query_response_example_img9.jpg
ELEM 3    39   1    390353    39                  
ELEM 3    39   1    390363    213                 
ELEM 3    39   1    390363    212                 /doc1/address_query_response_example_img10.jpg
ELEM 3    39   1    390363    211                 
ELEM 3    39   1    390363    210                 /doc1/address_query_response_example_img10.jpg
ELEM 3    39   1    390363    39                  
ELEM 3    39   1    390373    212                 /doc1/address_query_response_example_img11.jpg
ELEM 3    39   1    390373    213                 
ELEM 3    39   1    390373    211                 
ELEM 3    39   1    390373    210                 /doc1/address_query_response_example_img11.jpg
ELEM 3    39   1    390373    39                  
ELEM 7    2    1    418467    5                   IndexInPath is the index of the Type Definition in the Type Definition Path